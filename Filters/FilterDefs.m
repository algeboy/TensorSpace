declare type Flt;
declare attributes Flt: Boundary, Domain, Image, Indices, Max_Inds, Lattice, Length, Lex_Order, Lie_Alg, Lie_Func, Object, Preorder, Totally_Ordered;

/* 
  Description of attributes:
    Boundary . . . . . . . The filter's boundary filter.
    Domain . . . . . . . . An integer d, where the domain of the filter is N^d. 
    Image. . . . . . . . . A sequence of algebraic objects in the image.
    Indices. . . . . . . . A sequence of indices for the image.
    Max_Inds . . . . . . . True/false depending if the indicies are maximum or minimum.
    Lattice. . . . . . . . The lattice of the filter.
    Length . . . . . . . . The length of the filter.
    Lex_Order. . . . . . . True/false depending if the ordering is lexicographical.
    Lie_Alg. . . . . . . . The associated Lie algebra.
    Lie_Func . . . . . . . The associated functor to the Lie algebra.
    Object . . . . . . . . The algebraic object for which this is a filter for.
    Preorder . . . . . . . A user defined function for N^d. It acts like `less than or equal to'.
    Totally_Ordered. . . . True/false depending if the ordering is totally ordered.
*/

// ==============================================================================
//                             Constructors of filters
// ==============================================================================
__GetFilter := function( X, Inds, Im, P : TotallyOrdered := 0, MaxInds := true, Lex := false)
  F := New(Flt);
  F`Object := X;
  F`Indices := Inds;
  F`Image := Im;
  F`Domain := #Inds[1];
  F`Preorder := P;
  if Type(TotallyOrdered) ne RngIntElt then
    F`Totally_Ordered := TotallyOrdered;
  end if;
  F`Max_Inds := MaxInds;
  F`Lex_Order := Lex;
  return F;
end function;

intrinsic Filter( X::Any, D::SeqEnum, I::SeqEnum, P::UserProgram ) -> Flt
{Returns the filter into the subsets of X. 
The domain of the filter is generated by D, and the corresponding images are I.
The preorder is defined by P, where P(x,y) returns true if x `le' y.}
  return __GetFilter( X, D, I, P );
end intrinsic;

intrinsic TotallyOrderedFilter( X::Any, D::SeqEnum, I::SeqEnum, P::UserProgram : Lex := true ) -> Flt
{Returns the totally ordered filter into the subsets of X. 
The domain of the filter is generated by D, and the corresponding images are I.
The preorder is defined by P, where P(x,y) returns true if x `le' y.
If P is the lexicographical order set Lex to true.}
  require Type(Lex) eq BoolElt : "Parameter must be true/false.";
  return __GetFilter( X, D, I, P : TotallyOrdered := true, Lex := true );
end intrinsic;

// ------------------------------------------------------------------------------
//                                      Groups
// ------------------------------------------------------------------------------

intrinsic LowerCentralFilter( G::Grp ) -> Flt
{Returns the lower central filter for a group G.}
  try
    lcs := LowerCentralSeries(G);
  catch err
    error err`Object;
  end try;
  P := function(x,y)
    return x le y;
  end function;
  return __GetFilter( G, [ [i] : i in [1..#lcs] ], lcs, P : TotallyOrdered := true, Lex := true );
end intrinsic;

intrinsic pCentralFilter( G::Grp, p::RngIntElt ) -> Flt
{Returns the p-central filter for a group G.}
  try
    pcs := pCentralSeries(G,p);
  catch err
    error err`Object;
  end try;
  P := function(x,y)
    return x le y;
  end function;
  return __GetFilter( G, [ [i] : i in [1..#pcs] ], pcs, P : TotallyOrdered := true, Lex := true );
end intrinsic;

intrinsic pCentralFilter( G::GrpPC ) -> Flt
{Returns the p-central filter for a p-group G.}
  fact := Factorisation( #G );
  require #fact eq 1 : "Group is not a p-group.";
  p := fact[1][1];
  return pCentralFilter( G, p );
end intrinsic;

intrinsic JenningsFilter( G::Grp ) -> Flt
{Returns the Jennings filter for a group G.}
  if Type(G) eq GrpMat then
    require #Factorization(LMGOrder(G)) eq 1 : "Group must be a p-group.";
  else
    require #Factorization(#G) eq 1 : "Group must be a p-group.";
  end if;
  js := JenningsSeries(G);
  seq := Sort([ [Index(js,K)] : K in { H : H in js } ]);
  max := [ [1] ] cat [ [i[1]+1] : i in Remove(Prune(seq),1) ] cat [seq[#seq]];
  P := function(x,y)
    return x le y;
  end function;
  return __GetFilter( G, max, [ js[i][1] : i in seq ], P : TotallyOrdered := true, Lex := true );
end intrinsic;

// ==============================================================================
//                                      Basics
// ==============================================================================
intrinsic Print( F::Flt ) 
{Print F}
  d := F`Domain;
  str := Sprintf( "%o.", Type(F`Object) );
	if d eq 1 then
		printf "Filter from N into the subsets of " cat str;
	else;
		printf "Filter from N^" cat IntegerToString(d) cat " into the subsets of " cat str;
	end if;
end intrinsic;

intrinsic '@'( s::[RngIntElt], F::Flt ) -> .
{s @ F}
  require F`Totally_Ordered : "Filter must be totally ordered.";
  require #s eq F`Domain : "Element not in domain.";
  require forall{ t : t in s | t ge 0 } : "Element not in domain.";
  if s in F`Indices then
    return F`Image[Index(F`Indices,s)];
  end if;
  S := [ t : t in F`Indices | F`Preorder( s, t ) ];
  if #S eq 0 then
    H := F`Image[#F`Image];
    return H;
  end if;
  if exists(t){ t : t in S | forall{ u : u in S | F`Preorder( t, u ) } } then
    return F`Image[Index(F`Indices,t)];
  else
    H := sub< F`Object | >;
    return H;
  end if;
end intrinsic;

intrinsic '@'( s::RngIntElt, F::Flt ) -> .
{s @ F }
  return [s] @ F;
end intrinsic;

intrinsic 'eq'( F::Flt, G::Flt ) -> BoolElt
{ F eq G }
  if (F`Domain ne G`Domain) or (F`Max_Inds ne G`Max_Inds) or (F`Totally_Ordered ne G`Totally_Ordered) or (F`Indices ne G`Indices) then
    return false;
  end if;
  return F`Image eq G`Image;
end intrinsic;
