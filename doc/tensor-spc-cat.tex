
In Magma a tensor space is a parent type for tensors.  It behaves
as a module but also maintains an interpretation of its elements as
a multilinear map.  Each tensor space further maintains a tensor category
which is also assigned to its tensors.


\section{Constructions of tensor and cotensor spaces}

\subsection{Universal tensor spaces}

Construction of universal tensor spaces is modeled after construction of free 
modules and matrix spaces. For efficiency reasons, the actual representation 
may 
vary based on the parameters, e.g. it may be a space of structure constants, 
black-box functions, or systems of forms. So access to the tensors in these 
tensor space should be made through the provided functions.

\index{KTensorSpace}
\begin{intrinsics}
KTensorSpace(K, S) : Fld, [RngIntElt] -> TenSpc
KTensorSpace(K, S, C) : Fld, [RngIntElt], TenCat -> TenSpc
\end{intrinsics}

For a field $K$ and sequence $S=[d_{\vav},\cdots, d_0]$, 
returns the universal tensor space $\rversor_{a\in [\vav]} K^{d_a}$ with covariant tensor category given by $C$.
The default category is the homotopism category.

\index{RTensorSpace}
\begin{intrinsics}
RTensorSpace(R, S) : Rng, [RngIntElt] -> TenSpc
RTensorSpace(R, S, C) : Rng, [RngIntElt], TenCat -> TenSpc
\end{intrinsics}

For a commutative ring $R$ and sequence $S=[d_{\vav},\cdots, d_0]$, 
returns the universal tensor space $\rversor_{a\in [\vav]} R^{d_a}$ with covariant tensor category given by $C$.
The default category is the homotopism category.

\begin{example}[UniversalKTenSpc]

We demonstrate how to construct universal tensor spaces from a field $K=\mathbb{Q}$ and a sequence of nonnegative integers $[6,5,4,3]$. 
The resulting tensor space is isomorphic to the space of multilinear maps with frame 
\[ \mathbb{Q}^6\times \mathbb{Q}^5\times\mathbb{Q}^4\rightarrowtail\mathbb{Q}^3. \]
\begin{code}
> K := Rationals();
> S := [6, 5, 4, 3];
> T := KTensorSpace(K, S);
> T;
Tensor space of dimension 360 over Rational Field with valence 4
U3 : Full Vector space of degree 6 over Rational Field
U2 : Full Vector space of degree 5 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 3 over Rational Field
\end{code}

Because tensor spaces act like modules, we can construct tensors in the same way we construct vectors.
\begin{code}
> t := T![Random([-1, 0, 1]) : i in [1..Dimension(T)]];
> t;
Tensor of valence 4, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 6 over Rational Field
U2 : Full Vector space of degree 5 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 3 over Rational Field
> Parent(t);
Tensor space of dimension 360 over Rational Field with valence 4
U3 : Full Vector space of degree 6 over Rational Field
U2 : Full Vector space of degree 5 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 3 over Rational Field
\end{code}
\end{example}


\index{TensorSpace}
\begin{intrinsics}
TensorSpace(S) : SeqEnum -> TenSpc, List
TensorSpace(S) : List -> TenSpc, List
TensorSpace(S, C) : SeqEnum, TenCat -> TenSpc, List
TensorSpace(S, C) : List, TenCat -> TenSpc, List
\end{intrinsics}

Given a sequence $S=[U_{\vav},\dots, U_0]$ of $R$-modules returns a universal tensor 
space equivalent to $\rversor_{a\in[\vav]} U_a$ with covariant tensor 
category given by $C$ and a list of maps into the vector spaces in the frame. 
The default category is the homotopism category. 

\begin{example}[UniversalTenSpc]

We will construct a similar tensor space as the previous example. 
However, the objects will be different, according to Magma.
\begin{code}
> R := Integers();
> S := [* RMatrixSpace(R, 2, 3), RSpace(R, 5), RMatrixSpace(R, 2, 2), \
>     RSpace(R, 3) *];
> T := TensorSpace(S);
> T;
Tensor space of dimension 360 over Integer Ring with valence 4
U3 : Full RSpace of degree 6 over Integer Ring
U2 : Full RSpace of degree 5 over Integer Ring
U1 : Full RSpace of degree 4 over Integer Ring
U0 : Full RSpace of degree 3 over Integer Ring
\end{code}

Even though the frame of $T$ does not include matrix spaces, like with tensors, it can still evalute matrices. 
For example, we evaluate $T$ at $(0,0,0)$, which is the trivial subspace in $\mathbb{Z}^3$.
\begin{code}
> x := < X!0 : X in S[1..3] >;
> x;
<
    [0 0 0]
    [0 0 0],

    (0 0 0 0 0),

    [0 0]
    [0 0]
>
> x @ T;
RSpace of degree 3, dimension 0 over Integer Ring
Generators: 

\end{code}
\end{example}

\index{TensorSpace!signatured}
\begin{intrinsics}
TensorSpace(V, p, q) : ModTupFld, RngIntElt, RngIntElt -> TenSpc
TensorSpace(K, d, p, q) : Fld, RngIntElt, RngIntElt, RngIntElt -> TenSpc
\end{intrinsics}

Returns the signatured $(p,q)$-tensor space over the vector space $V=K^d$. 
The first $p$ indices are covariant and the last $q$ indices are contravariant.  
This is functionally equivalent
to creating a universal tensor space from the sequence 
$[V,\dots,_p V, V^*,\dots,_q V^*, K]$
and the tensor category with arrows $[1,\dots,_p 1, -1,\dots,_q -1, 0]$ and 
duplicates $\{\{p+q,\dots,1+q\},\{q,\dots,1\},\{0\}\}$.
The valence of the returned tensor space will be $p+q+1$. 

\begin{example}[SignaturedTenSpc]

Here we simply demonstrate the nuances of the signatured tensor space constructor.
We set $V=\mathbb{F}_5^4$, $p=3$, and $q=2$, and the tensor space we will construct will have frame 
\[ V\times V\times V \times V^* \times V^*\rightarrowtail\mathbb{F}_5. \]
Notice this is equivalent to the frame $V\times V\times V\rightarrowtail V \times V$. 
\begin{code}
> K := GF(5);
> T := TensorSpace(K, 4, 3, 2);
> T;
Tensor space of dimension 1024 over GF(5) with valence 6
U5 : Full Vector space of degree 4 over GF(5)
U4 : Full Vector space of degree 4 over GF(5)
U3 : Full Vector space of degree 4 over GF(5)
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 1 over GF(5)
> S := KTensorSpace(K, [4, 4, 4, 4, 4, 1]);
> S;
Tensor space of dimension 1024 over GF(5) with valence 6
U5 : Full Vector space of degree 4 over GF(5)
U4 : Full Vector space of degree 4 over GF(5)
U3 : Full Vector space of degree 4 over GF(5)
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 1 over GF(5)
\end{code}

However, the subtleties of this construction lies in the tensor category. 
On the surface, the spaces $T$ and $S$ look the same, but probing the category reveals their differences.
\begin{code}
> TensorCategory(S); // default category
Tensor category of valence 6 (->,->,->,->,->,->) ({ 1 },{ 2 },{ 0 },{ 3 },{ 4 
},{ 5 })
> TensorCategory(T); 
Tensor category of valence 6 (<-,<-,<-,->,->,==) ({ 0 },{ 3 .. 5 },{ 1 .. 2 })
> S eq T;
false
\end{code}
\end{example}


\subsection{Universal cotensor spaces}~

Currently, we only consider cotensor spaces over fields.

\index{KCotensorSpace}
\begin{intrinsics}
KCotensorSpace(K, S) : Fld, [RngIntElt] -> TenSpc
KCotensorSpace(K, S, C) : Fld, [RngIntElt], TenCat -> TenSpc
\end{intrinsics}

For a field $K$ and sequence $S=[d_{\vav},\dots, d_1]$ returns the universal cotensor 
space $\bigotimes_{a\in\comp{0}}K^{d_a}$ with the given contravariant tensor category $C$.
The default category is the homotopism category.
Notice the sequence $S$ indices do \emph{not} include 0.

\index{CotensorSpace}
\begin{intrinsics}
CotensorSpace(S) : SeqEnum -> TenSpc, List
CotensorSpace(S) : List -> TenSpc, List
CotensorSpace(S, C) : SeqEnum, TenCat -> TenSpc, List
CotensorSpace(S, C) : List, TenCat -> TenSpc, List
\end{intrinsics}

Given a sequence $S=[U_{\vav},\dots, U_1]$ of $K$-vector spaces returns the universal tensor 
space equivalent to $\bigotimes_{a\in\comp{0}}U_a$ with contravariant tensor 
category given by $C$ and a list of maps into the vector spaces of the frame. 
The default category is the homotopism category.
Notice the sequence $S$ indices do \emph{not} include 0.

\begin{example}[UniversalCoTenSpc]

Constructing cotensor spaces is nearly the same as constructing tensor spaces. 
When providing a sequence of modules or a sequence of dimensions, we do not include the entry for $U_0$. 
It is automatically set to $U_0=K$.
Furthermore, the black-box construction forgets all other structure of the vector spaces and only builds a frame out of vector spaces. 
The maps are returned as a \texttt{List} in case they are needed.
\begin{code}
> K := Rationals();
> S := [* KSpace(K, 3), MatrixAlgebra(K, 3), KMatrixSpace(K, 2, 3) *];
> S;
[*
    Full Vector space of degree 3 over Rational Field,
    Full Matrix Algebra of degree 3 over Rational Field,
    Full KMatrixSpace of 2 by 3 matrices over Rational Field
*]
> T := CotensorSpace(S);
> T;
Cotensor space of dimension 162 over Rational Field with valence 4
U3 : Full Vector space of degree 3 over Rational Field
U2 : Full Vector space of degree 9 over Rational Field
U1 : Full Vector space of degree 6 over Rational Field
\end{code}

Like with tensor spaces, cotensors are elements of cotensor spaces, and for many purposes in Magma, cotensor and tensor spaces have similar functionality. 
\begin{code}
> t := T.3;
> t;
Cotensor of valence 4, U3 x U2 x U1 >-> K
U3 : Full Vector space of degree 3 over Rational Field
U2 : Full Vector space of degree 9 over Rational Field
U1 : Full Vector space of degree 6 over Rational Field
> Eltseq(t);
[ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0 ]
\end{code}
\end{example}

\subsection{Some standard constructions}

We include some subspaces generated by well-known tensors.

\index{AlternatingSpace}
\begin{intrinsics}
AlternatingSpace(T) : TenSpc -> TenSpc, Map
\end{intrinsics}

Returns the sub(co-)tensor space generated by all the alternating (co-)tensors contained in the given (co-)tensor space and an embedding into $T$.

\index{AntisymmetricSpace}
\begin{intrinsics}
AntisymmetricSpace(T) : TenSpc -> TenSpc, Map
\end{intrinsics}

Returns the sub(co-)tensor space generated by all the antisymmetric (co-)tensors contained in the given (co-)tensor space and an embedding into $T$.

\index{SymmetricSpace}
\begin{intrinsics}
SymmetricSpace(T) : TenSpc -> TenSpc, Map
\end{intrinsics}

Returns the sub(co-)tensor space generated by all the symmetric (co-)tensors contained in the given (co-)tensor space  and an embedding into $T$.

\begin{example}[StandardTenSubspcs]

We will construct some standard tensor subspaces of the universal tensor space with frame $\mathbb{F}_3^4\times \mathbb{F}_3^4\rightarrowtail\mathbb{F}_3^4$.
\begin{code}
> K := GF(3);
> T := KTensorSpace(K, [4, 4, 4]);
> T;
Tensor space of dimension 64 over GF(5) with valence 3
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 4 over GF(5)
\end{code}

First, we will construct the subspace of $T$ containing all alternating bilinear maps.
Since $\binom{4}{2}=6$, we expect the subspace to be 24-dimensional in $T$. 
\begin{code}
> Alt := AlternatingSpace(T);
> Alt;
Tensor space of dimension 24 over GF(3) with valence 3
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 4 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
> t := Random(Alt);
> t;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 4 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
> IsAlternating(t);
true
\end{code}

Now we will construct the symmetric subspace of the alternating subspace, which is trivial.
\begin{code}
> S := SymmetricSpace(Alt);
> S;
Tensor space of dimension 0 over GF(3) with valence 3
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 4 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
\end{code}
\end{example}

\index{ExteriorCotensorSpace}
\begin{intrinsics}
ExteriorCotensorSpace(V, n) : ModTupFld, RngIntElt -> TenSpc
\end{intrinsics}

Returns the cotensor space given by the $n$th exterior power of the vector space $V$.

\index{SymmetricCotensorSpace}
\begin{intrinsics}
SymmetricCotensorSpace(V, n) : ModTupFld, RngIntElt -> TenSpc
\end{intrinsics}

Returns the cotensor space given by the $n$th symmetric power of the vector space $V$.

\begin{example}[StandardCoTenSubspcs]

We set $V=\mathbb{F}_5^6$ and we construct the cotensor space of the symmetric square of $V$, $V\wedge V$. 
The frame is $V\times V\rightarrowtail \mathbb{F}_5$, so the cotensor space is $\binom{6}{2}$-dimensional. 
\begin{code}
> V := VectorSpace(GF(5), 6);
> T := ExteriorCotensorSpace(V, 2);
> T;
Cotensor space of dimension 15 over GF(5) with valence 3
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
\end{code}

The cotensor space $T$ is generated by all alternating tensors $\bra{t} : V\times V\rightarrowtail \mathbb{F}_5$.
We will demonstrate by constructing a random cotensor from $T$. 
\begin{code}
> t := Random(T);
> t;
Cotensor of valence 3, U2 x U1 >-> K
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
> SystemOfForms(t);
[
    [0 2 2 2 4 1]
    [3 0 4 1 0 0]
    [3 1 0 3 1 1]
    [3 4 2 0 2 0]
    [1 0 4 3 0 2]
    [4 0 4 0 3 0]
]
> IsAlternating(t);
true
\end{code}

Notice this construction is not $V\times V\rightarrowtail V\wedge V$. 
However, if we want this tensor, we can use the intrinsic \texttt{AsTensor}.
\begin{code}
> s := AsTensor(T);
> s;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
U0 : Full Vector space of degree 15 over GF(5)
> IsAlternating(s);
true
\end{code}
\end{example}


\subsection{Subspaces as closures}~

The subspaces in this section are given by Galois connections in \cite{FMW:densors}*{Theorem~A}. 
Currently, these are the only closures that are constructible in this package, and they are implemented for 3-tensors.

\index{DerivationClosure}
\begin{intrinsics}
DerivationClosure(T, Delta) : TenSpc, AlgMat -> TenSpc
DerivationClosure(T, Delta) : TenSpc, ModMatFld -> TenSpc
DerivationClosure(T, Delta) : TenSpc, AlgMatLie -> TenSpc
DerivationClosure(T, Delta) : TenSpc, [Mtrx] -> TenSpc
DerivationClosure(T, Delta) : TenSpc, [AlgMatLie] -> TenSpc
\end{intrinsics}

Returns the derivation closure of the given tensor space $T$, with frame $U_2\times U_1\rightarrowtail U_0$, with operators $\Delta\subseteq \text{End}(U_2)\times \text{End}(U_1)\times \text{End}(U_0)$.
Currently, this only works for tensor spaces of valence 3.
This is the subspace whose tensors' derivation algebra contains $\Delta$.

\index{DerivationClosure}
\begin{intrinsics}
DerivationClosure(T, t) : TenSpc, TenSpcElt -> TenSpc
\end{intrinsics}

Returns the derivation closure of the given tensor space $T$, with frame $U_2\times U_1\rightarrowtail U_0$, whose operators are the derivation algebra of $t$. 
Currently, this only works for tensor spaces of valence 3.
This is the subspace whose tensors' derivation algebra contains the derivation algebra of $t$.

\begin{example}[Rank1Densor]

We illustrate the fact that the tensor for (hyper-)matrix multiplication spans its densor, see \cite{FMW:densors}*{Theorem~G}.
We will construct the derivation closure of $\bra{t}:\mathbb{M}_{2\times 3}(\mathbb{F}_3)\times \mathbb{M}_{3\times 2}(\mathbb{F}_3)\rightarrowtail \mathbb{M}_{2}(\mathbb{F}_3)$, given by matrix multiplcation. 
The derivation closure of $t$ in the universal tensor space $T$ is 1-dimensional.
\begin{code}
> Fr := [ KMatrixSpace(GF(3),2,3), KMatrixSpace(GF(3),3,2),
>     KMatrixSpace(GF(3),2,2) ];
> F := func< x | x[1]*x[2] >;
> t := Tensor(Fr, F);
> t;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 6 over GF(3)
U1 : Full Vector space of degree 6 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
\end{code}

The derivation algebra of $t$ is isomorphic to $(\mathfrak{gl}_2(\mathbb{F}_3)\oplus \mathfrak{gl}_3(\mathbb{F}_3)\oplus \mathfrak{gl}_2(\mathbb{F}_3))/\mathbb{F}_3$.
We do not show this, but we verify that the dimensions match.
\begin{code}
> D := DerivationAlgebra(t);
> Dimension(D) eq 4+9+4-1;
true
\end{code}

Now we verify that $t$ spans its own densor.
\begin{code}
> T := Parent(t);
> T;
Tensor space of dimension 144 over GF(3) with valence 3
U2 : Full Vector space of degree 6 over GF(3)
U1 : Full Vector space of degree 6 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
> densor := DerivationClosure(T, D);
> densor eq sub< T | t >;
true
\end{code}
\end{example}


\index{NucleusClosure}
\begin{intrinsics}
NucleusClosure(T, Delta, a, b) : TenSpc, AlgMat, RngIntElt, RngIntElt -> TenSpc
NucleusClosure(T, Delta, a, b) : TenSpc, ModMatFld, RngIntElt, RngIntElt -> TenSpc
NucleusClosure(T, Delta, a, b) : TenSpc, [Mtrx], RngIntElt, RngIntElt -> TenSpc
\end{intrinsics}

Returns the nucleus closure of the tensor space $T$, with frame $U_2\times U_1\rightarrowtail U_0$, with operators $\Delta\subseteq \text{End}(U_a)\times \text{End}(U_b)$.
Currently, this only works for tensor spaces of valence 3.
This returns the subspace whose tensors' $\{a,b\}$-nuclues contains $\Delta$.

\index{NucleusClosure}
\begin{intrinsics}
NucleusClosure(T, t, a, b) : TenSpc, TenSpcElt, RngIntElt, RngIntElt -> TenSpc
\end{intrinsics}

Returns the nucleus closure of the tensor space $T$, with frame $U_2\times U_1\rightarrowtail U_0$, whose operators are the $\{a,b\}$-nucleus of $t$.
Currently, this only works for tensor spaces of valence 3.
This returns the subspace whose tensors' $\{a,b\}$-nuclues contains the $\{a,b\}$-nucleus of $t$.

\begin{example}[NucClosure]

We illustrate that if $t$ is the commutator tensor from the Heisenberg group, then the densor of $t$ is $\text{Cen}(t)\cdot t$, 1-dimensional over the centroid.
First, we construct $t$ with frame $\mathbb{F}_5^6\times\mathbb{F}_5^6\rightarrowtail \mathbb{F}_5^3$, so that $t$ is $\mathbb{F}_5$-bilinear.
\begin{code}
> H := ClassicalSylow(GL(3,125), 5);
> t := pCentralTensor(H);
> t;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
U0 : Full Vector space of degree 3 over GF(5)
\end{code}

Because $t$ came from the Heisenberg group over $\mathbb{F}_{5^3}$, the centroid of $t$ will be 3-dimensional (over $\mathbb{F}_5$) and isomorphic to $\mathbb{F}_{5^3}$.
After computing the centroid of $t$, we will rewrite $t$ over the centroid $\text{Cen}(t)$, so that $t$ is $\mathbb{F}_{5^3}$-bilinear.
\begin{code}
> C := Centroid(t);
> C;
Matrix Algebra of degree 15 and dimension 3 with 3 generators over GF(5)
> s := TensorOverCentroid(t);
> s;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(5^3)
U1 : Full Vector space of degree 2 over GF(5^3)
U0 : Full Vector space of degree 1 over GF(5^3)
\end{code}

Now we will compute the nucleus closure of both $s$ and $t$ at $\{2,1\}$.
The dimension of the closure of $s$ will be 1-dimensional, while the dimension of the closure for $t$ will not.
\begin{code}

\end{code}
\end{example}

\section{Operations on tensor spaces}

\subsection{Membership and comparison with tensor spaces}

We define some intuitive functions for tensor spaces, similar to those found for modules.

\index{in}
\begin{intrinsics}
t in T : TenSpcElt, TenSpc -> BoolElt
\end{intrinsics}

Decides if $t$ is contained in the tensor space $T$.

\index{IsCoercible!tensor}\index{BANG!tensor}
\begin{intrinsics}
IsCoercible(T, t) : TenSpc, TenSpcElt -> BoolElt, TenSpcElt
T ! t : TenSpc, TenSpcElt -> BoolElt, TenSpcElt
\end{intrinsics}

Decides if the tensor $t$ can be coerced into the tensor space $T$. If so, the tensor is returned as an element of $T$.

\index{IsCoercible!sequence}\index{BANG!sequence}
\begin{intrinsics}
IsCoercible(T, S) : TenSpc, SeqEnum -> BoolElt, TenSpcElt
T ! S : TenSpc, SeqEnum -> BoolElt, TenSpcElt
\end{intrinsics}

Decides if the sequence $S$ can be coerced into the tensor space $T$ as a tensor. If so, the corresponding tensor is returned. 

\index{IsCoercible!zero}\index{BANG!zero}
\begin{intrinsics}
IsCoercible(T, n) : TenSpc, RngIntElt -> BoolElt, TenSpcElt
T ! n : TenSpc, RngIntElt -> BoolElt, TenSpcElt
\end{intrinsics}

This is a shortcut designed to only work when $n=0$, and thus, return {\tt true} and the zero tensor from the tensor space. 
Any other integer will yield an error.

\begin{example}[Coercion]
We illustrate that using \texttt{!} is the same as creating the tensor from scratch.

\begin{code}
> T := KTensorSpace( GF(2), [2,3,2] );
> T;
Tensor space of dimension 12 over GF(2) with valence 3
U2 : Full Vector space of degree 2 over GF(2)
U1 : Full Vector space of degree 3 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> 
> S := [ 1 : i in [1..12] ];
> t := T!S;
> t;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(2)
U1 : Full Vector space of degree 3 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> 
> t eq Tensor(GF(2), [2,3,2], S);
true
> 
> T!0 in T;
true
> SystemOfForms(T!0);
[
    [0 0 0]
    [0 0 0],

    [0 0 0]
    [0 0 0]
]
\end{code}

\end{example}

\index{eq!tensor space}
\begin{intrinsics}
S eq T : TenSpc, TenSpc -> BoolElt
\end{intrinsics}

Decides if the tensor spaces $S$ and $T$ are equal.

\index{subset}
\begin{intrinsics}
S subset T : TenSpc, TenSpc -> BoolElt
\end{intrinsics}

Decides if $S$ is a subset of the tensor space $T$.

\index{IsCoercible!tensor space}\index{BANG!tensor space}
\begin{intrinsics}
IsCoercible(T, S) : TenSpc, TenSpc -> BoolElt, TenSpc
T ! S : TenSpc, TenSpc -> BoolElt, TenSpc
\end{intrinsics}

Decides if the tensor space $S$ can be coerced into the tensor space $T$ as a subspace. If so, the corresponding subspace is returned. 

\begin{example}[TenSpcContainment]

We construct the universal tensor space $T$ with the frame $\mathbb{F}_2^4\times \mathbb{F}_2^4\rightarrowtail \mathbb{F}_2^4$. 
We also create a tensor space $T_2$ with frame $\mathbb{F}_2^4\times \mathbb{F}_2\times \mathbb{F}_2^4\times\mathbb{F}_2\rightarrowtail \mathbb{F}_2^4$.

\begin{code}
> T := KTensorSpace(GF(2), [4,4,4]);
> T;
Tensor space of dimension 64 over GF(2) with valence 3
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 4 over GF(2)
> 
> T2 := KTensorSpace(GF(2), [4,1,4,1,4]);
> T2;
Tensor space of dimension 64 over GF(2) with valence 5
U4 : Full Vector space of degree 4 over GF(2)
U3 : Full Vector space of degree 1 over GF(2)
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 1 over GF(2)
U0 : Full Vector space of degree 4 over GF(2)
> 
> S := sub< T | T.2, T.4, T.8 >;
> S;
Tensor space of dimension 3 over GF(2) with valence 3
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 4 over GF(2)
\end{code}

We verify that $S$ is a subset of $T$ and not $T_2$. 
Since the tensors of $T$ naturally embed into $T_2$, the subspace $S$ can be coerced into $T_2$, which we label as $S_2$. 
We then verify that $S_2$ is a subset of $T_2$ and not $T$. 
\begin{code}
> S subset T2;
false
> S2 := T2!S;
> S2 subset T2;
true
> S2 subset T;
false
\end{code}
\end{example}

\subsection{Tensor spaces as modules}

We view a tensor space as a $K$-module, so we have notions of generators, 
dimension (if it is free), and cardinality.

\index{Generators}\index{Basis}
\begin{intrinsics}
Basis(T) : TenSpc -> SeqEnum
Generators(T) : TenSpc -> SeqEnum
\end{intrinsics}

Returns a basis for the tensor space $T$. 

\index{.!tensor space}
\begin{intrinsics}
T.i : TenSpc, RngIntElt -> TenSpcElt
\end{intrinsics}

Returns the $i$th basis tensor of the tensor space $T$.

\index{NumberOfGenerators}\index{Ngens}
\begin{intrinsics}
NumberOfGenerators(T) : TenSpc -> RngIntElt
Ngens(T) : TenSpc -> RngIntElt
\end{intrinsics}

Returns the number of generators of the tensor space $T$.

\index{Dimension}
\begin{intrinsics}
Dimension(T) : TenSpc -> RngIntElt
\end{intrinsics}

Returns the dimension of the tensor space $T$ as a free $K$-module.

\index{\#}
\begin{intrinsics}
# T : TenSpc -> RngIntElt
\end{intrinsics}

Returns the size of the tensor space, provided $T$ is finite.

\begin{example}[BasicModule]

We demonstrate the basic module functions of tensor spaces.
We construct the universal tensor space $T$ with frame $\mathbb{F}_8^3\times\mathbb{F}_8^5\rightarrowtail\mathbb{F}_8^7$.
\begin{code}
> K := GF(8);
> T := KTensorSpace(K, [3,5,7]);
> T;
Tensor space of dimension 105 over GF(2^3) with valence 3
U2 : Full Vector space of degree 3 over GF(2^3)
U1 : Full Vector space of degree 5 over GF(2^3)
U0 : Full Vector space of degree 7 over GF(2^3)
\end{code} 

Now we obtain module properties of $T$.
\begin{code}
> Dimension(T);
105
> #Basis(T);
105
> T.100 in Basis(T);
true
> T.100;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(2^3)
U1 : Full Vector space of degree 5 over GF(2^3)
U0 : Full Vector space of degree 7 over GF(2^3)
> #T eq 8^(3*5*7);
true
\end{code}
\end{example}

\index{Random}
\begin{intrinsics}
Random(T) : TenSpc -> TenSpcElt
\end{intrinsics}

Provided the base ring has a random algorithm in Magma, it returns a random 
element of the tensor space $T$.

\index{RandomTensor}\index{RandomCotensor}
\begin{intrinsics}
RandomTensor(R, S) : Rng, [RngIntElt] -> TenSpcElt
RandomTensor(R, S, C) : Rng, [RngIntElt], TenCat -> TenSpcElt
RandomCotensor(K, S) : Fld, [RngIntElt] -> TenSpcElt
\end{intrinsics}

Provided $R$ has a random algorithm in Magma, it returns a random (co)tensor from 
the universal (co)tensor space $\rversor_{s\in S} R^{s}$, with category $C$.
The default category is the homotopism category.

\begin{example}[RandomTensors]

We create some random tensors, which works similarly to \texttt{RandomMatrix} in Magma.
There are two main ways to obtain a random tensor: from a given tensor space or from a ring and a dimension sequence (the universal tensor space). 
First we will construct the alternating tensor space of the universal tensor space with frame $\mathbb{F}_3^4\times\mathbb{F}_3^4\rightarrowtail \mathbb{F}_3^2$.
\begin{code}
> T := KTensorSpace(GF(3), [4,4,2]);
> T;
Tensor space of dimension 32 over GF(3) with valence 3
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 4 over GF(3)
U0 : Full Vector space of degree 2 over GF(3)
> S := AlternatingSpace(T);
> S;
Tensor space of dimension 12 over GF(3) with valence 3
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 4 over GF(3)
U0 : Full Vector space of degree 2 over GF(3)
\end{code}

Now we construct a random alternating tensor from $S$.
\begin{code}
> t := Random(S);
> t;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 4 over GF(3)
U0 : Full Vector space of degree 2 over GF(3)
> SystemOfForms(t);
[
    [0 0 0 1]
    [0 0 1 2]
    [0 2 0 0]
    [2 1 0 0],

    [0 2 1 2]
    [1 0 1 2]
    [2 2 0 0]
    [1 1 0 0]
]
\end{code}
\end{example}

\subsection{Properties of tensor spaces}

We define some functions to access basic properties of tensor spaces.

\index{Valence!tensor space}
\begin{intrinsics}
Valence(T) : TenSpc -> RngIntElt
\end{intrinsics}

Returns the valence of the tensor space.

\index{Frame!tensor space}
\begin{intrinsics}
Frame(T) : TenSpc -> List
\end{intrinsics}

Returns the list of modules in the frame of the tensor space.

\index{BaseRing!tensor space}\index{BaseField!tensor space}
\begin{intrinsics}
BaseRing(T) : TenSpc -> Rng
BaseField(T) : TenSpc -> Fld
\end{intrinsics}

Returns the base ring (or field) of the tensor space.

\begin{example}[TenSpcProperties]

As with tensors, we can obtain the basic tensor properties from a tensor space.
\begin{code}
> T := KTensorSpace(Rationals(), [7,5,3,2]);
> T;
Tensor space of dimension 210 over Rational Field with valence 4
U3 : Full Vector space of degree 7 over Rational Field
U2 : Full Vector space of degree 5 over Rational Field
U1 : Full Vector space of degree 3 over Rational Field
U0 : Full Vector space of degree 2 over Rational Field
> Valence(T);
4
> Frame(T);
[*
    Full Vector space of degree 7 over Rational Field,

    Full Vector space of degree 5 over Rational Field,

    Full Vector space of degree 3 over Rational Field,

    Full Vector space of degree 2 over Rational Field
*]
> BaseRing(T);
Rational Field
\end{code}
\end{example}


\index{TensorCategory!tensor space}
\begin{intrinsics}
TensorCategory(T) : TenSpc -> TenCat
\end{intrinsics}

Returns the underlying tensor category of the tensor space.

\index{IsCovariant!tensor space}\index{IsContravariant!tensor space}
\begin{intrinsics}
IsCovariant(T) : TenSpc -> BoolElt
IsContravariant(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if the underlying tensor category is covariant or contravariant.

\index{ChangeTensorCategory!tensor space}
\begin{intrinsics}
ChangeTensorCategory(T, C) : TenSpc, TenCat -> TenSpc
ChangeTensorCategory(~T, C) : TenSpc, TenCat
\end{intrinsics}

Returns the tensor category with the given tensor category.

\begin{example}[TenSpcCategories]

Again, like with tensors, we can obtain categorical information from tensor spaces.
\begin{code}
> T := KTensorSpace(Rationals(), [4,4,4]);
> T;
Tensor space of dimension 64 over Rational Field with valence 3
U2 : Full Vector space of degree 4 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 4 over Rational Field
> 
> TensorCategory(T);
Tensor category of valence 3 (->,->,->) ({ 1 },{ 2 },{ 0 })
> C := TensorCategory([1,1,-1], {{0},{1,2}});
> C;
Tensor category of valence 3 (->,->,<-) ({ 0 },{ 1, 2 })
> 
> ChangeTensorCategory(~T, C);
> T;
Tensor space of dimension 64 over Rational Field with valence 3
U2 : Full Vector space of degree 4 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 4 over Rational Field
> TensorCategory(T);
Tensor category of valence 3 (->,->,<-) ({ 0 },{ 1, 2 })
\end{code}
\end{example}


\index{IsAlternating!tensor space}
\begin{intrinsics}
IsAlternating(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if every tensor in the tensor space is an alternating tensor.

\index{IsAntisymmetric!tensor space}
\begin{intrinsics}
IsAntisymmetric(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if every tensor in the tensor space is an antisymmetric tensor.

\index{IsSymmetric!tensor space}
\begin{intrinsics}
IsSymmetric(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if every tensor in the tensor space is a symmetric tensor.

\index{UniversalTensorSpace}\index{UniversalCotensorSpace}\index{Generic}
\begin{intrinsics}
UniversalTensorSpace(T) : TenSpc -> TenSpc
UniversalCotensorSpace(T) : TenSpc -> TenSpc
Generic(T) : TenSpc -> TenSpc
\end{intrinsics}

Returns the universal (co-)tensor space with the same frame and category as $T$.

\begin{example}[UniversalConst]

We construct the subspace of alternating tensors $S$ of the tensor space $T$ with the frame $\mathbb{Q}^6\times\mathbb{Q}^6\rightarrowtail \mathbb{Q}^2$. 
We verify that the space is in fact alternating (i.e.\ every tensor is alternating).
\begin{code}
> T := KTensorSpace(Rationals(), [6,6,2]);
> S := AlternatingSpace(T);
> S;
Tensor space of dimension 30 over Rational Field with valence 3
U2 : Full Vector space of degree 6 over Rational Field
U1 : Full Vector space of degree 6 over Rational Field
U0 : Full Vector space of degree 2 over Rational Field
> IsAlternating(S);
true
\end{code}

From $S$, we construct the universal tensor space $U$, which in this example is equal to $T$. 
\begin{code}
> U := UniversalTensorSpace(S);
> U;
Tensor space of dimension 72 over Rational Field with valence 3
U2 : Full Vector space of degree 6 over Rational Field
U1 : Full Vector space of degree 6 over Rational Field
U0 : Full Vector space of degree 2 over Rational Field
> U eq T;
true
\end{code}
\end{example}





\chapter{Tensor categories}\label{ch:tensor-categories}

Magma allows tensors and tensor spaces to change categories. 
Unless a user specifies otherwise,
all tensors are assigned a category that is natural to the method
by which it was created.
For example a tensor created from an algebra will be assigned an 
algebra category, whereas a tensor created by structure constants
will be assigned the Albert homotopism category \cite{Albert:Fundamentals}.  
Tensor categories influence
the behavior of commands such as kernels and images  
as well as the algebraic invariants such as derivation algebras of a tensor.  

Our conventions follow \cite{Wilson:division}.  In particular given
a tensor $t$ framed by $[U_{\vav},\dots,U_0]$ then a tensor category for
$t$ will specify a function $A:[\vav]\to \{-1,0,1\}$ along with
a partition $\mathcal{P}$ of $[\vav]$ such that the following 
rules apply to the tensors and morphisms in the category.
\begin{enumerate}
\item for each tensor $t$ framed by $[U_{\vav},\dots,U_0]$, if
$X\in\mathcal{P}$, then 
$$\forall i,j\in X,\quad U_i=U_j.$$

\item Given a second tensor $s$ framed by $[V_{\vav},\dots,V_0]$,
a morphism $f:t\to s$ (Magma type {\tt Hmtp}) will be a list
$[f_{\vav},\dots,f_0]$ of homomorphisms as follows:
\begin{itemize}
\item (Covariant) if $A(i)=1$ then $f_i:U_i\to V_i$;
\item (Constant) if $A(i)=0$ then $U_i=V_i$ and $f_i=1_{U_i}$; or else
\item (Contravariant) $A(i)=-1$ and $f_i:U_i\leftarrow V_i$.
\end{itemize}
So if $A(0)=1$ then
\begin{align*}
	\left\langle \sum_{i\in A^{-1}(1)} u_i f_i
		+\sum_{j\not\in A^{-1}(-1)} v_j\right\rangle_S
		& = \left\langle  \sum_{i\in A^{-1}(1)} u_i 
		+\sum_{j\not\in A^{-1}(-1)} v_j f_j\right\rangle_T f_0;
\end{align*}
if $A(0)=0$ then
\begin{align*}
	\left\langle \sum_{i\in A^{-1}(1)} u_i f_i
		+\sum_{j\not\in A^{-1}(-1)} v_j\right\rangle_S
		& = \left\langle  \sum_{i\in A^{-1}(1)} u_i 
		+\sum_{j\not\in A^{-1}(-1)} v_j f_j\right\rangle_T;
\end{align*}
else $A(0)=-1$ and 
\begin{align*}
	\left\langle \sum_{i\in A^{-1}(1)} u_i f_i
		+\sum_{j\not\in A^{-1}(-1)} v_j\right\rangle_S f_0
		& = \left\langle  \sum_{i\in A^{-1}(1)} u_i 
		+\sum_{j\not\in A^{-1}(-1)} v_j f_j\right\rangle_T.
\end{align*}
\end{enumerate}

Magma manages internally the differences between 
vectors and covectors and more generally tensors and cotensors.
Both types are issued the Magma type {\tt TenSpcElt}.
For operations sensitive to the difference, Magma stores a value of
co/contra-variance of the tensor as a property of the tensor category.
This the third general property stored in Magma's tensor category type
{\tt TenCat}.

We use the phrase tensor category exclusively for categories that describe tensors and tensor spaces.
In other words, the data structure of a tensor category is a function 
$A:[\vav]\rightarrow \{-1,0,1\}$ and a partition $\mathcal{P}$ of $[\vav]$.
It is useful to distinguish from tensors and cotensors at the categorical level,
so a tensor category is either covariant or contravariant as well 
(in the latter case, referred to as a cotensor category).

\section{Constructing tensor categories}~

\index{TensorCategory!constructor}
\begin{intrinsics}
TensorCategory(A, P) : [RngIntElt], {SetEnum} -> TenCat
TensorCategory(A, P) : Map, {SetEnum} -> TenCat
\end{intrinsics}

Sets up a covariant tensor space category with specified direction of
arrows $A$, and a partition $\mathcal{P}$ indicating variables to be treated as
equivalent.  The fiber $A^{-1}(1)$ denotes the covariant variables,
$A^{-1}(0)$ identifies the constant variables, and $A^{-1}(-1)$ marks
the contra-variant variables.  

\index{CotensorCategory!constructor}
\begin{intrinsics}
CotensorCategory(A, P) : [RngIntElt], {SetEnum} -> TenCat
CotensorCategory(A, P) : Map, {SetEnum} -> TenCat
\end{intrinsics}

Sets up a contra-variant tensor space category with specified direction of
arrows $A$, and a partition $\mathcal{P}$ indicating variables to be treated as
equivalent.  The fiber $A^{-1}(1)$ denotes the covariant variables,
$A^{-1}(0)$ identifies the constant variables, and $A^{-1}(-1)$ marks
the contra-variant variables.  

\begin{example}[BasicCatConst]

We demonstrate the basic tensor category constructor. 
The only difference between \texttt{TensorCategory} and \texttt{CotensorCategory} is that the former is covariant and the latter is contravariant.
\begin{code}
> C := TensorCategory([1,0,-1], {{0},{1},{2}});
> C;
Tensor category of valence 3 (->,==,<-) ({ 1 },{ 2 },{ 0 })
> IsCovariant(C);
true
> 
> arrows := map< {1..5} -> {1} | x :-> 1 >;
> C := CotensorCategory(arrows, {{1..5}});
> C;
Cotensor category of valence 6 (->,->,->,->,->,==) ({ 0 },{ 1 .. 5 })
> IsContravariant(C);
true
\end{code}
\end{example}


\index{HomotopismCategory}
\begin{intrinsics}
HomotopismCategory(v : parameters) : RngIntElt -> TenCat
    Contravariant : BoolElt : false
\end{intrinsics}

Returns Albert's homotopism category -- all modules categories are covariant 
and 
no duplicates considered.
Set the optional parameter {\tt Contravariant} to {\tt true} to make it a cotensor category.

\index{CohomotopismCategory}
\begin{intrinsics}
CohomotopismCategory(v) : RngIntElt -> TenCat
\end{intrinsics}

Returns the cohomotopism category -- all domain modules categories are 
covariant, the codomain is contravariant, and no duplicates considered.

\index{AdjointCategory}\index{LinearCategory}
\begin{intrinsics}
AdjointCategory(v, s, t) :  RngIntElt, RngIntElt, RngIntElt -> TenCat
LinearCategory(v, s, t) :  RngIntElt, RngIntElt, RngIntElt -> TenCat
\end{intrinsics}

Returns the tensor category where all modules are constant except in position 
$s$ and $t$.  Both $s$ and $t$ are in $[v]$.
Position $s$ is covariant, position $t$ is contravariant.

\begin{example}[TenCatSpecial]

Now we look at a few special tensor category constructors.
The default tensor category is the homotopism category, so we construct the homotopism category using \texttt{TensorCategory} and verify they are equivalent.
\begin{code}
> C := TensorCategory([1,1,1,1], {{i} : i in [0..3]});
> C;
Tensor category of valence 4 (->,->,->,->) ({ 1 },{ 2 },{ 0 },{ 3 })
> HomotopismCategory(4) eq C;
true
\end{code}

The other special tensor categories can be constructed using \texttt{TensorCategory} as well, but we just construct a few to show their properties.
\begin{code}
> CohomotopismCategory(3);
Tensor category of valence 3 (->,->,<-) ({ 1 },{ 2 },{ 0 })
> 
> AdjointCategory(5, 4, 1);
Tensor category of valence 5 (<-,==,==,->,==) ({ 1 },{ 0, 2, 3 },{ 4 })
\end{code}
\end{example}

\section{Operations on tensor categories}

We have basic operations for tensor categories.

\index{eq!tensor category}
\begin{intrinsics}
C1 eq C2 : TenCat, TenCat -> BoolElt
\end{intrinsics}

Decides if the tensor categories are the same.

\index{Valence!tensor category}
\begin{intrinsics}
Valence(C) : TenCat -> RngIntElt
\end{intrinsics}

Returns the valence of the tensor category.

\index{Arrows}
\begin{intrinsics}
Arrows(C) : TenCat -> SeqEnum
\end{intrinsics}

Returns the sequence of arrows of the tensor category. 
A $-1$ signifies an a contravariant index, a $0$ signifies a constant index, and a $1$ signifies a covariant index.

\index{RepeatPartition}
\begin{intrinsics}
RepeatPartition(C) : TenCat -> SetEnum
\end{intrinsics}

Returns the repeat partition for the tensor category.

\index{IsCovariant!tensor category}\index{IsContravariant!tensor category}
\begin{intrinsics}
IsCovariant(C) : TenCat -> BoolElt
IsContravariant(C) : TenCat -> BoolElt
\end{intrinsics}

Decides if the tensor category is covariant or contravariant.

\begin{example}[TenCatProperties]

We obtain basic properties of tensor categories.
\begin{code}
> C := CotensorCategory([1,0,-1,1],{{4,3},{1},{2}});
> C;
Cotensor category of valence 5 (->,==,<-,->,==) ({ 1 },{ 2 },{ 0 },{ 3, 4 })
> 
> Valence(C);
5
> Arrows(C);
[ 1, 0, -1, 1 ]
> IsContravariant(C);
true
> RepeatPartition(C);
{
    { 1 },
    { 2 },
    { 3, 4 }
}
\end{code}
\end{example}



\section{Categorical operations}

\subsection{Categorical operations on tensors}

We include functions defined for the category of tensors.
Most functions are currently defined only for the homotopism category.

\index{Subtensor}
\begin{intrinsics}
Subtensor(t, S) : TenSpcElt, List -> TenSpcElt
\end{intrinsics}

Returns the smallest submap of $t$ containing $S$.

\index{Subtensor}
\begin{intrinsics}
Subtensor(t, D, C) : TenSpcElt, List, Any -> TenSpcElt
\end{intrinsics}

Returns the smallest submap of $t$ containing $D$ in the domain and $C$ in the 
codomain.

\index{IsSubtensor}
\begin{intrinsics}
IsSubtensor(t, s) : TenSpcElt, TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $s$ is a subtensor of $t$.

\begin{example}[Subtensors]

\end{example}


\index{LocalIdeal}
\begin{intrinsics}
LocalIdeal(T, S, I) : TenSpcElt, List, {RngIntElt} -> TenSpcElt
\end{intrinsics}

Returns the local ideal of $T$ at $I$ constaining $S$.

\index{LocalIdeal}
\begin{intrinsics}
LocalIdeal(T, D, C, I) : TenSpcElt, List, Any, {RngIntElt} -> TenSpcElt
\end{intrinsics}

Returns the local ideal of $T$ at $I$ constaining $D$ in the domain and $C$ 
in the codomain.

\index{LocalIdeal}
\begin{intrinsics}
LocalIdeal(T, S, I) : TenSpcElt, TenSpcElt, {RngIntElt} -> TenSpcElt
\end{intrinsics}

Returns the local ideal of $T$ at $I$ constaining $S$ as a submap.


\index{IsLocalIdeal}
\begin{intrinsics}
IsLocalIdeal(T, S, I) : TenSpcElt, TenSpcElt, {RngIntElt} -> BoolElt
\end{intrinsics}

Decides if $S$ is a local ideal of $T$ at $I$.

\index{Ideal}
\begin{intrinsics}
Ideal(T, S) : TenSpcElt, List -> TenSpcElt
\end{intrinsics}

Returns the ideal of $T$ containing $S$.

\index{Ideal}
\begin{intrinsics}
Ideal(T, D, C) : TenSpcElt, List, Any -> TenSpcElt
\end{intrinsics}

Returns the ideal of $T$ containing $D$ in the domain and $C$ in the codomain.

\index{Ideal}
\begin{intrinsics}
Ideal(T, S) : TenSpcElt, TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the ideal of $T$ containing $S$ as a submap.

\index{IsIdeal}
\begin{intrinsics}
IsIdeal(T, S) : TenSpcElt, TenSpcElt -> BoolElt
\end{intrinsics}

Decides if $S$ is an ideal of $T$.

\index{LocalQuotient}
\begin{intrinsics}
LocalQuotient(T, S, I : parameters) : TenSpcElt, TenSpcElt, {RngIntElt} -> TenSpcElt, Hmtp
    Check : BoolElt : true
\end{intrinsics}

Returns the local quotient of $T$ by $S$ at $I$. If you know $S$ is a local 
ideal of $T$ at $I$, set {\tt Check} to {\tt false} to skip the verification.
A homotopism is also returned, mapping from $T$ to $T/S$.

\index{Quotient!tensor}\index{/!tensor}
\begin{intrinsics}
Quotient(T, S : parameters) : TenSpcElt, TenSpcElt -> TenSpcElt, Hmtp
    Check : BoolElt : true
T / S : TenSpcElt, TenSpcElt -> TenSpcElt, Hmtp
\end{intrinsics}

Returns the quotient of $T$ by $S$. If you know $S$ is an ideal of $T$, 
set {\tt Check} to {\tt false} to skip the verification.
A homotopism is also returned, mapping from $T$ to $T/S$.

\begin{example}[Ten\_Cat\_Ops]
We will construct a quotient of tensors. First, we construct a subtensor from a random tensor.

\begin{code}
> T := RandomTensor(GF(5),[4,4,2]);
> T := RandomTensor(GF(5),[4,4,2]);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 2 over GF(5)
> 
> F := Frame(T);
> L := [* F[1]![1,1,1,0], F[2]![0,0,0,1], F[3]![0,0] *];
> S := Subtensor(T,L);
> S;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(1 1 1 0)
Echelonized basis:
(1 1 1 0)
U1 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(0 0 0 1)
Echelonized basis:
(0 0 0 1)
U0 : Vector space of degree 2, dimension 1 over GF(5)
Generators:
(0 2)
Echelonized basis:
(0 1)
> 
> IsSubtensor(T,S);
true
\end{code}

Now we construct the ideal of $T$ containing $S$.

\begin{code}
> I := Ideal(T,S);
> I;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(1 1 1 0)
Echelonized basis:
(1 1 1 0)
U1 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(0 0 0 1)
Echelonized basis:
(0 0 0 1)
U0 : Full Vector space of degree 2 over GF(5)
Generators:
(1 0)
(0 1)
> 
> IsIdeal(T,I);
true
\end{code}

Finally, we construct the quotient of $T$ by $I$.

\begin{code}
> T/I;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(5)
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 0 over GF(5)
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: Mapping from: Full Vector space of degree 4 over 
GF(5) to Full Vector space of degree 3 over GF(5)
U1 -> V1: Mapping from: Full Vector space of degree 4 over 
GF(5) to Full Vector space of degree 3 over GF(5)
U0 -> V0: Mapping from: Full Vector space of degree 2 over 
GF(5) to Full Vector space of degree 0 over GF(5)
\end{code}
\end{example}

\subsection{Categorical operations on tensor spaces}

We have categorical notions for tensor spaces as well.

\index{SubConstructor!tensor space}\index{sub!tensor space}
\begin{intrinsics}
SubConstructor(T, L) : TenSpc, Any -> TenSpc, Map
sub< T | L > : TenSpc, Any -> TenSpc, Map
\end{intrinsics}

Returns the subtensor space of $T$ generated by the tensors in the sequence $L$.

%\index{SubtensorSpace}
%\begin{intrinsics}
%SubtensorSpace(T, L) : TenSpc, [TenSpcElt] -> TenSpc
%\end{intrinsics}

%Returns the subtensor space of $T$ generated by the tensors in the sequence $L$.

%\index{SubtensorSpace}
%\begin{intrinsics}
%SubtensorSpace(T, t) : TenSpc, TenSpcelt -> TenSpc
%\end{intrinsics}

%Returns the subtensor space of $T$ generated by the tensor $t$.

\index{IsSubtensorSpace}
\begin{intrinsics}
IsSubtensorSpace(T, S) : TenSpc, TenSpc -> BoolElt
\end{intrinsics}

Decides if the tensor space $S$ is a subtensor space of $T$.

\index{QuoConstructor!tensor space}\index{quo!tensor space}\index{/!tensor space}
\begin{intrinsics}
QuoConstructor(T, S) : TenSpc, TenSpc -> TenSpc, Map
quo< T | S > : TenSpc, TenSpc -> TenSpc, Map
T / S : TenSpc, TenSpc -> TenSpc, Map
\end{intrinsics}

Returns the quotient tensor space of $T$ by $S$.

\begin{example}[TenSpc\_Cat\_Ops]
We construct a subtensor space.

\begin{code}
> T := KTensorSpace(GF(2),[4,4,2]);
> T;
Tensor space of dimension 32 over GF(2) with valence 2
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> 
> L := [ T.i : i in [1..Ngens(T)] | IsEven(i) ];
> S := SubtensorSpace(T, L);
> S;
Tensor space of dimension 16 over GF(2) with valence 2
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> SystemOfForms(Random(S));
[
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0],

    [1 0 0 0]
    [0 1 0 1]
    [1 0 0 0]
    [0 0 1 0]
]
\end{code}

Now we compute the quotient tensor space $Q=T/S$.

\begin{code}
> Q := T/S;
> Q;
Tensor space of dimension 16 over GF(2) with valence 2
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> SystemOfForms(Random(Q));
[
    [0 0 0 0]
    [1 1 1 0]
    [1 0 1 1]
    [1 1 0 1],

    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
]
> SystemOfForms(Q![1 : i in [1..32]]);
[
    [1 1 1 1]
    [1 1 1 1]
    [1 1 1 1]
    [1 1 1 1],

    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
]
\end{code}
\end{example}

\section{Homotopisms}

Magma provides functions for homotopisms. Homotopisms are also equipped with a tensor category.

\subsection{Constructions of Homotopisms}~

\index{Homotopism}
\begin{intrinsics}
Homotopism(T, S, M : parameters) : TenSpcElt, TenSpcElt, List -> Hmtp
    Check : BoolElt
Homotopism(T, S, M, C : parameters) : TenSpcElt, TenSpcElt, List, TenCat -> Hmtp
    Check : BoolElt
\end{intrinsics}

Returns the homotopism from $T$ to $S$ given by the list of maps $M$ and the category $C$. 
The default tensor category is the same as tensor categories for $T$ and $S$.

\begin{example}[Hmtp\_Const]
We illustrate how to construct tensor categories.

\begin{code}
> TS := KTensorSpace(GF(4),[2,3,4]);
> T := Random(TS);
> S := Random(TS);
> M := [* Random(KMatrixSpace(GF(4),i,i)) : i in [2..4] *];
> H := Homotopism(T,S,M);
> H;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[    1     0]
[    0     0]
U1 -> V1: 
[    0   $.1 $.1^2]
[    1     1   $.1]
[  $.1   $.1 $.1^2]
U0 -> V0: 
[    1     1   $.1 $.1^2]
[    0     1 $.1^2   $.1]
[    0     0   $.1 $.1^2]
[  $.1 $.1^2   $.1     0]
> 
> 
> M[2] := map< Frame(TS)[2] -> Frame(TS)[2] | x :-> x >;
> H2 := Homotopism(T,S,M);
> H2;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[    1     0]
[    0     0]
U1 -> V1: Mapping from: Full Vector space of degree 3 
over GF(2^2) to Full Vector space of degree 3 over GF(2^2) 
given by a rule [no inverse]
U0 -> V0: 
[    1     1   $.1 $.1^2]
[    0     1 $.1^2   $.1]
[    0     0   $.1 $.1^2]
[  $.1 $.1^2   $.1     0]
\end{code}
\end{example}


\subsection{Basic Operations with Homotopisms}

We provide some operations for homotopisms.

\index{$*$!homotopism}
\begin{intrinsics}
H1 * H2 : Hmtp, Hmtp -> Hmtp
\end{intrinsics}

Returns the composition of the homotopisms $H_1$ and $H_2$.

\index{Domain!homotopism}
\begin{intrinsics}
Domain(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the domain tensor of $H$.

\index{Codomain!homotopism}
\begin{intrinsics}
Codomain(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the codomain tensor of $H$.

\index{Maps}
\begin{intrinsics}
Maps(H) : Hmtp -> List
\end{intrinsics}

Returns the list of maps for the various modules in the domain and codomain 
tensors.

\index{.!homotopisms}
\begin{intrinsics}
H.i : Hmtp, RngIntElt -> Map
\end{intrinsics}

Returns the map on the $i$th coordinate.

\index{TensorCategory!homotopism}
\begin{intrinsics}
TensorCategory(H) : Hmtp -> TenCat
\end{intrinsics}

Returns the tensor category of $H$.

\index{ChangeTensorCategory!homotopism}
\begin{intrinsics}
ChangeTensorCategory(H, C) : Hmtp, TenCat -> Hmtp
ChangeTensorCategory(~H, C) : Hmtp, TenCat -> Hmtp
\end{intrinsics}

Changes the tensor category of $H$ to the given category.

\index{Kernel}
\begin{intrinsics}
Kernel(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the kernel of $H$ as an ideal of its domain tensor.

\index{Image!homotopism}
\begin{intrinsics}
Image(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the image of $H$ as a submap of the codomain tensor.

\begin{example}[Hmtp\_Ops]
We perform basic operations with homotopisms.

\begin{code}
> T := RandomTensor(GF(7),[5,4,3]);
> F := Frame(T);
> 
> I := [* hom< F[j] -> F[j] | [< F[j].i,F[j].i > :\
>   i in [1..Dimension(F[j])]] > : j in [1..3] *];
> H := Homotopism(T,T,I);
> 
> Image(H);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 5 over GF(7)
U1 : Full Vector space of degree 4 over GF(7)
U0 : Full Vector space of degree 3 over GF(7)
> Kernel(H);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 5, dimension 0 over GF(7)
U1 : Vector space of degree 4, dimension 0 over GF(7)
U0 : Vector space of degree 3, dimension 0 over GF(7)
\end{code}

If the tensor is over vector spaces, then matrices can be used to create a homotopism.

\begin{code}
> M := [* RandomMatrix(GF(7),i,i) : i in [5,4,3] *];
> G := Homotopism(T,T,M);
> G;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[5 3 6 0 4]
[6 0 0 1 1]
[6 4 3 1 5]
[3 4 6 1 4]
[2 4 1 3 2]
U1 -> V1: 
[5 5 0 3]
[3 5 1 3]
[3 6 1 5]
[2 3 5 4]
U0 -> V0: 
[6 4 1]
[2 6 5]
[1 2 3]
\end{code}

Homotopisms can be composed so long as Magma can compose each of the individual maps.

\begin{code}
> G*G;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[3 6 3 0 5]
[0 5 1 4 2]
[1 5 0 2 1]
[2 4 4 2 2]
[4 2 0 0 5]
U1 -> V1: 
[4 3 6 0]
[4 6 0 6]
[4 3 4 3]
[0 4 0 0]
U0 -> V0: 
[3 1 1]
[1 5 5]
[6 1 6]
\end{code}

We can change the underlying category for the homotopism $G$ to get a different morphism.

\begin{code}
> Cat := TensorCategory([1,-1,1],{{0},{1},{2}});
> G := Homotopism(T,T,M,Cat);
> G;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[5 3 6 0 4]
[6 0 0 1 1]
[6 4 3 1 5]
[3 4 6 1 4]
[2 4 1 3 2]
U1 <- V1: 
[5 5 0 3]
[3 5 1 3]
[3 6 1 5]
[2 3 5 4]
U0 -> V0: 
[6 4 1]
[2 6 5]
[1 2 3]
> 
> Image(G);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 5 over GF(7)
U1 : Vector space of degree 4, dimension 0 over GF(7)
U0 : Vector space of degree 3, dimension 2 over GF(7)
Echelonized basis:
(1 0 4)
(0 1 3)
> 
> Kernel(G);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 5, dimension 0 over GF(7)
U1 : Full Vector space of degree 4 over GF(7)
U0 : Vector space of degree 3, dimension 1 over GF(7)
Echelonized basis:
(1 4 0)
\end{code}
\end{example}

