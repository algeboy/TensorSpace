
In Magma a tensor space is a parent type for tensors.  It behaves
as a module but also maintains an interpretation of its elements as
a multilinear map.  Each tensor space further maintains a tensor category
which is assigned to its tensors.


\section{Constructions of tensor and cotensor spaces}

\subsection{Universal tensor spaces}

Construction of universal tensor spaces is modeled after construction of free 
modules and matrix spaces. For efficiency reasons, the actual representation 
may 
vary based on the parameters, e.g. it may be a space of structure constants, 
black-box functions, or systems of forms. So access to the tensors in these 
tensor space should be made through the provided functions.

\index{KTensorSpace}
\begin{intrinsics}
KTensorSpace(K, S) : Fld, [RngIntElt] -> TenSpc
KTensorSpace(K, S, C) : Fld, [RngIntElt], TenCat -> TenSpc
\end{intrinsics}

For a field $K$ and sequence $S=[d_v,\cdots, d_0]$, 
returns the universal tensor space $\hom_K(K^{d_v},\dots ,\hom_K(K^{d_1},K^{d_0})\cdots )\cong K^{d_v\cdots d_0}$
with covariant tensor category given by $C$.
The default is Albert's homotopism category.

\index{RTensorSpace}
\begin{intrinsics}
RTensorSpace(R, S) : Rng, [RngIntElt] -> TenSpc
RTensorSpace(R, S, C) : Rng, [RngIntElt], TenCat -> TenSpc
\end{intrinsics}

For a commutative and unital ring $R$ and sequence $S=[d_v,\cdots, d_0]$, 
returns the universal tensor space $\hom_R(R^{d_v},\dots ,\hom_R(R^{d_1},R^{d_0})\cdots )\cong R^{d_v\cdots d_0}$
with covariant tensor category given by $C$.
The default is Albert's homotopism category.

\index{TensorSpace}
\begin{intrinsics}
TensorSpace(S) : SeqEnum -> TenSpc
TensorSpace(S) : List -> TenSpc
TensorSpace(S, C) : SeqEnum, TenCat -> TenSpc
TensorSpace(S, C) : List, TenCat -> TenSpc
\end{intrinsics}

Given a sequence $S=[U_v,\dots, U_0]$ of $K$-modules returns a universal tensor 
space equivalent to $\hom_K(U_v\otimes_K\cdots\otimes_K U_1,U_0)$ with covariant tensor 
category given by $C$. The default is Albert's homotopism category. 

\index{TensorSpace!signatured}
\begin{intrinsics}
TensorSpace(V, p, q) : ModTupFld, RngIntElt, RngIntElt -> TenSpc
TensorSpace(K, d, p, q) : Fld, RngIntElt, RngIntElt, RngIntElt -> TenSpc
\end{intrinsics}

Returns the signatured $(p,q)$-tensor space over the vector space $V=K^d$. 
The first $p$ indices are covariant and the last $q$ indices are contravariant.  
This is functionally equivalent
to creating a universal tensor space from the sequence 
$[V,\dots,_p V, V^*,\dots,_q V^*]$
and the tensor category with arrows $[1,\dots,_p 1, -1,\dots,_q -1]$ and 
duplicates $\{\{p+q,\dots,1+q\},\{q,\dots,1\},\{0\}\}$.

\begin{example}[TenSpc\_Const]
We demonstrate how to construct universal tensor spaces.

\begin{code}
> TS := KTensorSpace(Rationals(),[ i : i in [3..7] ]);
> TS;
Tensor space of dimension 2520 over Rational Field with 
valence 4
U4 : Full Vector space of degree 3 over Rational Field
U3 : Full Vector space of degree 4 over Rational Field
U2 : Full Vector space of degree 5 over Rational Field
U1 : Full Vector space of degree 6 over Rational Field
U0 : Full Vector space of degree 7 over Rational Field
> 
> TS.1;
Tensor of valence 4, U4 x U3 x U2 x U1 >-> U0
U4 : Full Vector space of degree 3 over Rational Field
U3 : Full Vector space of degree 4 over Rational Field
U2 : Full Vector space of degree 5 over Rational Field
U1 : Full Vector space of degree 6 over Rational Field
U0 : Full Vector space of degree 7 over Rational Field
\end{code}

Give a tensor space a frame.

\begin{code}
> R := pAdicRing(3,6);
> Fr := [RSpace(R,5), sub<RSpace(R,3)|[0,1,0],[0,0,1]>,\
>   RSpace(R,2)];
> TS := TensorSpace(Fr);
> TS;
Tensor space of dimension 20 over 3-adic ring mod 3^6 with 
valence 2
U2 : Full RSpace of degree 5 over pAdicRing(3, 6)
U1 : RSpace of degree 3, dimension 2 over pAdicRing(3, 6)
Generators:
(0 1 0)
(0 0 1)
Echelonized basis:
(0 1 0)
(0 0 1)
U0 : Full RSpace of degree 2 over pAdicRing(3, 6)
> 
> TS.10;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full RSpace of degree 5 over pAdicRing(3, 6)
U1 : RSpace of degree 3, dimension 2 over pAdicRing(3, 6)
Generators:
(0 1 0)
(0 0 1)
Echelonized basis:
(0 1 0)
(0 0 1)
U0 : Full RSpace of degree 2 over pAdicRing(3, 6)
\end{code}

With signatured tensor spaces, the tensor category is not immediately obvious at print out. 
Instead, one can glean categorical information using {\tt TensorCategory} on a tensor space.

\begin{code}
> TS := TensorSpace( VectorSpace(GF(3),3), 2, 4 );
> TS;
Tensor space of dimension 729 over GF(3) with valence 6
U6 : Full Vector space of degree 3 over GF(3)
U5 : Full Vector space of degree 3 over GF(3)
U4 : Full Vector space of degree 3 over GF(3)
U3 : Full Vector space of degree 3 over GF(3)
U2 : Full Vector space of degree 3 over GF(3)
U1 : Full Vector space of degree 3 over GF(3)
U0 : Full Vector space of degree 1 over GF(3)
> 
> TensorCategory(TS);
Tensor category of Valence 6 (<-,<-,->,->,->,->,==)
({ 0 },{ 5 .. 6 },{ 1 .. 4 })
\end{code}

We see that the indices 5 and 6 are contravariant and both are linked together as well. Furthermore the covariant indices are 1--4, which are also linked together.
\end{example}

\subsection{Universal cotensor spaces}~

We only consider cotensor spaces over fields.

\index{KCotensorSpace}
\begin{intrinsics}
KCotensorSpace(K, S) : Fld, [RngIntElt] -> TenSpc
KCotensorSpace(K, S, C) : Fld, [RngIntElt], TenCat -> TenSpc
\end{intrinsics}

For a field $K$ and sequence $S=[d_v,\dots, d_1]$ returns the universal cotensor 
space $\hom_K(K^{d_v}\otimes \cdots \otimes K^{d_1},K)\cong K^{d_v\cdots d_1}$ with the given contravariant tensor category $C$.
The default is Albert's homotopism category.

\index{CotensorSpace}
\begin{intrinsics}
CotensorSpace(S) : SeqEnum -> TenSpc
CotensorSpace(S) : List -> TenSpc
CotensorSpace(S, C) : SeqEnum, TenCat -> TenSpc
CotensorSpace(S, C) : List, TenCat -> TenSpc
\end{intrinsics}

Given a sequence $S=[U_v,\dots, U_1]$ of $K$-vector spaces returns the universal tensor 
space equivalent to $\hom_K(U_v\otimes_K\cdots\otimes_K U_1,K)$ with contravariant tensor 
category given by $C$. The default is Albert's homotopism category.

\begin{example}[CoTenSpc\_Const]
We construct cotensor spaces in the same way as we do tensor spaces.

\begin{code}
> CT := KCotensorSpace(GF(2),[ i : i in [5..7] ]);
> CT;
Cotensor space of dimension 210 over GF(2) with valence 2
U3 : Full Vector space of degree 5 over GF(2)
U2 : Full Vector space of degree 6 over GF(2)
U1 : Full Vector space of degree 7 over GF(2)
> 
> CT.1;
Cotensor of valence 2, U3 x U2 x U1 >-> K
U3 : Full Vector space of degree 5 over GF(2)
U2 : Full Vector space of degree 6 over GF(2)
U1 : Full Vector space of degree 7 over GF(2)
> 
> 
> Cat := CotensorCategory([1,0,-1],{{1},{2},{3}});
> Fr := [ VectorSpace(GF(8),4) : i in [1..3] ];
> CT := CotensorSpace( Fr, Cat );
> CT;
Cotensor space of dimension 64 over GF(2^3) with valence 2
U3 : Full Vector space of degree 4 over GF(2^3)
U2 : Full Vector space of degree 4 over GF(2^3)
U1 : Full Vector space of degree 4 over GF(2^3)
> 
> TensorCategory(CT);
Cotensor category of valence 2 (->,==,<-) ({ 1 },{ 2 },{ 3 })
\end{code}
\end{example}

\subsection{Some standard constructions}

We include some subspaces generated by well-known tensors.

\index{AlternatingSpace}
\begin{intrinsics}
AlternatingSpace(T) : TenSpc -> TenSpc
\end{intrinsics}

Returns the sub(co-)tensor space generated by all the alternating (co-)tensors contained in the given (co-)tensor space.

\index{AntisymmetricSpace}
\begin{intrinsics}
AntisymmetricSpace(T) : TenSpc -> TenSpc
\end{intrinsics}

Returns the sub(co-)tensor space generated by all the antisymmetric (co-)tensors contained in the given (co-)tensor space.

\index{SymmetricSpace}
\begin{intrinsics}
SymmetricSpace(T) : TenSpc -> TenSpc
\end{intrinsics}

Returns the sub(co-)tensor space generated by all the symmetric (co-)tensors contained in the given (co-)tensor space.

\index{ExteriorCotensorSpace}
\begin{intrinsics}
ExteriorCotensorSpace(V, n) : ModTupFld, RngIntElt -> TenSpc
\end{intrinsics}

Returns the cotensor space given by the $n$th exterior power of the vector space $V$.

\index{SymmetricCotensorSpace}
\begin{intrinsics}
SymmetricCotensorSpace(V, n) : ModTupFld, RngIntElt -> TenSpc
\end{intrinsics}

Returns the cotensor space given by the $n$th symmetric power of the vector space $V$.

\begin{example}[TenSpc\_Const2]
We construct the symmetric subtensor space of the universal tensor space.

\begin{code}
> TS := KTensorSpace(GF(3), [3,3,3,2]);
> TS;
Tensor space of dimension 54 over GF(3) with valence 3
U3 : Full Vector space of degree 3 over GF(3)
U2 : Full Vector space of degree 3 over GF(3)
U1 : Full Vector space of degree 3 over GF(3)
U0 : Full Vector space of degree 2 over GF(3)
> 
> SS := SymmetricSpace(TS);
> AsMatrices(Random(SS),3,2);
[
    [1 1 1]
    [1 0 0]
    [1 0 0],

    [2 2 2]
    [2 0 1]
    [2 1 0],

    [1 0 0]
    [0 1 2]
    [0 2 2],

    [2 0 1]
    [0 1 1]
    [1 1 2],

    [1 0 0]
    [0 2 2]
    [0 2 1],

    [2 1 0]
    [1 1 2]
    [0 2 0]
]
\end{code}

For $V=\mathbb{F}_{25}^6$, we construct the fourth exterior power of $V$, $\Lambda^4(V)$ 
as a sub cotensor space of dimension $\binom{6}{4}=15$.

\begin{code}
> V := VectorSpace(GF(25),6);
> E := ExteriorCotensorSpace(V,4);
> E;
Cotensor space of dimension 15 over GF(5^2) with valence 3
U4 : Full Vector space of degree 6 over GF(5^2)
U3 : Full Vector space of degree 6 over GF(5^2)
U2 : Full Vector space of degree 6 over GF(5^2)
U1 : Full Vector space of degree 6 over GF(5^2)
> 
> T := Random(E);
> IsAlternating(T);
true
\end{code}
\end{example}

\subsection{Subspaces as closures}~

\index{DerivationClosure}
\begin{intrinsics}
DerivationClosure(TS, O) : TenSpc, AlgMat -> TenSpc
DerivationClosure(TS, O) : TenSpc, ModMatFld -> TenSpc
DerivationClosure(TS, O) : TenSpc, AlgMatLie -> TenSpc
DerivationClosure(TS, O) : TenSpc, [Mtrx] -> TenSpc
DerivationClosure(TS, O) : TenSpc, [AlgMatLie] -> TenSpc
\end{intrinsics}

Returns the derivation closure of the given tensor space $TS$, with frame $U_2\times U_1\rightarrowtail U_0$, with operators $O\subseteq \text{End}(U_2)\times \text{End}(U_1)\times \text{End}(U_0)$.
Currently, this only works for tensor spaces of valence 2.
This is the subspace whose tensors' derivation algebra contains $O$.

\index{DerivationClosure}
\begin{intrinsics}
DerivationClosure(TS, T) : TenSpc, TenSpcElt -> TenSpc
\end{intrinsics}

Returns the derivation closure of the given tensor space $TS$, with frame $U_2\times U_1\rightarrowtail U_0$, with operators $O\subseteq \text{End}(U_2)\times \text{End}(U_1)\times \text{End}(U_0)$.
Currently, this only works for tensor spaces of valence 2.
This is the subspace whose tensors' derivation algebra contains the derivation algebra of $T$.

\index{NucleusClosure}
\begin{intrinsics}
NucleusClosure(TS, O, s, t) : TenSpc, AlgMat, RngIntElt, RngIntElt -> TenSpc
NucleusClosure(TS, O, s, t) : TenSpc, ModMatFld, RngIntElt, RngIntElt -> TenSpc
NucleusClosure(TS, O, s, t) : TenSpc, [Mtrx], RngIntElt, RngIntElt -> TenSpc
\end{intrinsics}

Returns the nucleus closure of the tensor space $TS$, with frame $U_2\times U_1\rightarrowtail U_0$, with operators $O\subseteq \text{End}(U_s)\times \text{End}(U_t)$.
Currently, this only works for tensor spaces of valence 2.
This returns the subspace whose tensors' $st$-nuclues contains $O$.

\index{NucleusClosure}
\begin{intrinsics}
NucleusClosure(TS, T, s, t) : TenSpc, TenSpcElt, RngIntElt, RngIntElt -> TenSpc
\end{intrinsics}

Returns the nucleus closure of the tensor space $TS$, with frame $U_2\times U_1\rightarrowtail U_0$, with operators $O\subseteq \text{End}(U_s)\times \text{End}(U_t)$.
Currently, this only works for tensor spaces of valence 2.
This returns the subspace whose tensors' $st$-nuclues contains the $st$-nucleus of $T$.

\begin{example}[Der\_Closure]
We illustrate the fact that the (hyper-)matrix multiplication is unique. 
The derivation closure of the tensor in the universal tensor space is 1-dimensional.

\begin{code}
> Fr := [ KMatrixSpace(GF(3),2,3),
>   KMatrixSpace(GF(3),3,2),KMatrixSpace(GF(3),2,2) ];
> F := func< x | x[1]*x[2] >;
> T := Tensor(Fr,F);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full KMatrixSpace of 2 by 3 matrices over GF(3)
U1 : Full KMatrixSpace of 3 by 2 matrices over GF(3)
U0 : Full KMatrixSpace of 2 by 2 matrices over GF(3)
> 
> TS := Parent(T);
> TS;
Tensor space of dimension 144 over GF(3) with valence 2
U2 : Full Vector space of degree 6 over GF(3)
U1 : Full Vector space of degree 6 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
> 
> D := DerivationClosure(TS,T);
> D;
Tensor space of dimension 1 over GF(3) with valence 2
U2 : Full Vector space of degree 6 over GF(3)
U1 : Full Vector space of degree 6 over GF(3)
U0 : Full Vector space of degree 4 over GF(3)
\end{code}
\end{example}

\begin{example}[Nuc\_Closure]
We illustrate that the commutator from the Heisenberg group is unique over the correct field.

\begin{code}
> H := ClassicalSylow( GL(3,125), 5 ); // Heisenberg group
> T := pCentralTensor(H,5,1,1);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
U0 : Full Vector space of degree 3 over GF(5)
\end{code}

The centroid of $T$ will be 3-dimensional and is isomorphic to $\mathbb{F}_{125}$.

\begin{code}
> C := Centroid(T);
> C;
Matrix Algebra of degree 15 with 3 generators over GF(5)
> 
> S := TensorOverCentroid(T);
> S;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(5^3)
U1 : Full Vector space of degree 2 over GF(5^3)
U0 : Full Vector space of degree 1 over GF(5^3)
> 
> TS := Parent(S);
> N := NucleusClosure(TS,S,2,1);
> N;
Tensor space of dimension 1 over GF(5^3) with valence 2
U2 : Full Vector space of degree 2 over GF(5^3)
U1 : Full Vector space of degree 2 over GF(5^3)
U0 : Full Vector space of degree 1 over GF(5^3)
\end{code}

Compare this closure with the closure of our original tensor over $\mathbb{F}_5$.

\begin{code}
> NT := NucleusClosure(Parent(T),T,2,1);
> NT;
Tensor space of dimension 36 over GF(5) with valence 2
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
U0 : Full Vector space of degree 3 over GF(5)
\end{code}
\end{example}

\section{Operations on tensor spaces}

\subsection{Membership and comparison with tensor spaces}

We define some intuitive functions for tensor spaces, similar to those found for modules.

\index{in}
\begin{intrinsics}
T in TS : TenSpcElt, TenSpc -> BoolElt
\end{intrinsics}

Decides if $T$ is contained in the tensor space $TS$.

\index{IsCoercible!tensor}\index{BANG!tensor}
\begin{intrinsics}
IsCoercible(TS, T) : TenSpc, TenSpcElt -> BoolElt, TenSpcElt
TS ! T : TenSpc, TenSpcElt -> BoolElt, TenSpcElt
\end{intrinsics}

Decides if the tensor $T$ can be coerced into the tensor space $TS$. If so, the tensor is returned as an element of $TS$.

\index{IsCoercible!sequence}\index{BANG!sequence}
\begin{intrinsics}
IsCoercible(TS, S) : TenSpc, SeqEnum -> BoolElt, TenSpcElt
TS ! S : TenSpc, SeqEnum -> BoolElt, TenSpcElt
\end{intrinsics}

Decides if the sequence $S$ can be coerced into the tensor space $TS$ as a tensor. If so, the corresponding tensor is returned. 

\index{IsCoercible!zero}\index{BANG!zero}
\begin{intrinsics}
IsCoercible(TS, n) : TenSpc, RngIntElt -> BoolElt, TenSpcElt
TS ! n : TenSpc, RngIntElt -> BoolElt, TenSpcElt
\end{intrinsics}

This is a shortcut designed to only work when $n=0$, and thus, return {\tt true} and the zero tensor from the tensor space. 
Any other integer will yield an error.

\index{eq!tensor space}
\begin{intrinsics}
S eq T : TenSpc, TenSpc -> BoolElt
\end{intrinsics}

Decides if the tensor spaces $S$ and $T$ are equal.

\index{subset}
\begin{intrinsics}
S subset T : TenSpc, TenSpc -> BoolElt
\end{intrinsics}

Decides if $S$ is a subset of the tensor space $T$.

\begin{example}[TenCoerce]
We illustrate that using {\tt !} is the same as creating the tensor from scratch.

\begin{code}
> TS := KTensorSpace( GF(2), [2,3,2] );
> TS;
Tensor space of dimension 12 over GF(2) with valence 2
U2 : Full Vector space of degree 2 over GF(2)
U1 : Full Vector space of degree 3 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> 
> S := [ Random(GF(2)) : i in [1..12] ];
> T := TS!S;
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(2)
U1 : Full Vector space of degree 3 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> 
> T eq Tensor(GF(2),[2,3,2],S);
true
\end{code}

We demonstrate how to coerce into the symmetric cube of $V=\mathbb{Q}^{10}$ and construct a subcotensor space.

\begin{code}
> V := VectorSpace(Rationals(),10);
> SS := SymmetricCotensorSpace(V,3);
> SS;
Cotensor space of dimension 220 over Rational Field with valence 2
U3 : Full Vector space of degree 10 over Rational Field
U2 : Full Vector space of degree 10 over Rational Field
U1 : Full Vector space of degree 10 over Rational Field
> 
> CT := SubtensorSpace(SS,SS![1..1000]);
> CT;
Cotensor space of dimension 1 over Rational Field with valence 2
U3 : Full Vector space of degree 10 over Rational Field
U2 : Full Vector space of degree 10 over Rational Field
U1 : Full Vector space of degree 10 over Rational Field
> 
> CT subset SS;
true
> CT.1 in SS;
true
> SS.2 in CT;
false
\end{code}
\end{example}

\subsection{Tensor spaces as modules}

We view a tensor space as a $K$-module, so we have notions of generators, 
dimension (if it is free), and cardinality.

\index{Generators}\index{Basis}
\begin{intrinsics}
Basis(T) : TenSpc -> SeqEnum
Generators(T) : TenSpc -> SeqEnum
\end{intrinsics}

Returns a basis for the tensor space. 

\index{.!tensor space}
\begin{intrinsics}
T.i : TenSpc, RngIntElt -> TenSpcElt
\end{intrinsics}

Returns the $i$th basis tensor of the tensor space $T$.

\index{NumberOfGenerators}\index{Ngens}
\begin{intrinsics}
NumberOfGenerators(T) : TenSpc -> RngIntElt
Ngens(T) : TenSpc -> RngIntElt
\end{intrinsics}

Returns the number of generators of the tensor space $T$.

\index{Dimension}
\begin{intrinsics}
Dimension(T) : TenSpc -> RngIntElt
\end{intrinsics}

Returns the dimension of the tensor space $T$ as a free $K$-module.

\index{\#}
\begin{intrinsics}
# T : TenSpc -> RngIntElt
\end{intrinsics}

Returns the size of the tensor space, provided it is finite.

\index{Random}
\begin{intrinsics}
Random(T) : TenSpc -> TenSpcElt
\end{intrinsics}

Provided the base ring has a random algorithm in Magma, it returns a random 
element of the tensor space $T$.

\index{RandomTensor}\index{RandomCotensor}
\begin{intrinsics}
RandomTensor(R, S) : Rng, [RngIntElt] -> TenSpcElt
RandomTensor(R, S, C) : Rng, [RngIntElt], TenCat -> TenSpcElt
RandomCotensor(K, S) : Fld, [RngIntElt] -> TenSpcElt
\end{intrinsics}

Provided $R$ has a random algorithm in Magma, it returns a random (co)tensor from 
the (co)tensor space $\hom_R(R^{d_v},\dots,\hom_R(R^{d_1},R^{d_0})\cdots )$ with category $C$.
The default category is the homotopism category.

\begin{example}[TenSpc\_Module]
We demonstrate the module functions for a tensor space.

\begin{code}
> TS := KTensorSpace( GF(9), [2,2,2,2] );
> TS;
Tensor space of dimension 16 over GF(3^2) with valence 3
U3 : Full Vector space of degree 2 over GF(3^2)
U2 : Full Vector space of degree 2 over GF(3^2)
U1 : Full Vector space of degree 2 over GF(3^2)
U0 : Full Vector space of degree 2 over GF(3^2)
> 
> Ngens(TS);
16
> #TS eq 9^Ngens(TS);
true
> 
> Eltseq(TS.2);
[ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
\end{code}

We can use {\tt RandomTensor} to get a random tensor or cotensor from scratch.

\begin{code}
> T := RandomTensor(GF(3),[2,2,2]);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(3)
U1 : Full Vector space of degree 2 over GF(3)
U0 : Full Vector space of degree 2 over GF(3)
> 
> Cat := CotensorCategory([1,1,1],{{1,2,3}});
> T := RandomTensor(GF(3),[2,2,2],Cat);
> T;
Cotensor of valence 2, U3 x U2 x U1 >-> K
U3 : Full Vector space of degree 2 over GF(3)
U2 : Full Vector space of degree 2 over GF(3)
U1 : Full Vector space of degree 2 over GF(3)
\end{code}
\end{example}

\subsection{Properties of tensor spaces}

We define some functions to access basic properties of tensor spaces.

\index{Valence!tensor space}
\begin{intrinsics}
Valence(T) : TenSpc -> RngIntElt
\end{intrinsics}

Returns the valence of the tensor space.

\index{Frame!tensor space}
\begin{intrinsics}
Frame(T) : TenSpc -> List
\end{intrinsics}

Returns the list of modules in the frame of the tensor space.

\index{BaseRing!tensor space}\index{BaseField!tensor space}
\begin{intrinsics}
BaseRing(T) : TenSpc -> Rng
BaseField(T) : TenSpc -> Fld
\end{intrinsics}

Returns the base ring (or field) of the tensor space.

\index{TensorCategory!tensor space}
\begin{intrinsics}
TensorCategory(T) : TenSpc -> TenCat
\end{intrinsics}

Returns the underlying tensor category of the tensor space.

\index{IsCovariant!tensor space}\index{IsContravariant!tensor space}
\begin{intrinsics}
IsCovariant(T) : TenSpc -> BoolElt
IsContravariant(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if the underlying tensor category is covariant or contravariant.

\index{ChangeTensorCategory!tensor space}
\begin{intrinsics}
ChangeTensorCategory(T, C) : TenSpc, TenCat -> TenSpc
ChangeTensorCategory(~T, C) : TenSpc, TenCat
\end{intrinsics}

Returns the tensor category with the given tensor category.

\index{IsAlternating!tensor space}
\begin{intrinsics}
IsAlternating(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if every tensor in the tensor space is an alternating tensor.

\index{IsAntisymmetric!tensor space}
\begin{intrinsics}
IsAntisymmetric(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if every tensor in the tensor space is an antisymmetric tensor.

\index{IsSymmetric!tensor space}
\begin{intrinsics}
IsSymmetric(T) : TenSpc -> BoolElt
\end{intrinsics}

Decides if every tensor in the tensor space is a symmetric tensor.

\index{UniversalTensorSpace}\index{UniversalCotensorSpace}\index{Generic}
\begin{intrinsics}
UniversalTensorSpace(T) : TenSpc -> TenSpc
UniversalCotensorSpace(T) : TenSpc -> TenSpc
Generic(T) : TenSpc -> TenSpc
\end{intrinsics}

Returns the universal (co-)tensor space with the same frame and category as $T$.

\begin{example}[TenSpc\_Prop]
We demonstrate the functions to obtain standard tensor space properties.

\begin{code}
> TS := KTensorSpace( GF(23), [3,4,5,6] );
> TS;
Tensor space of dimension 360 over GF(23) with valence 3
U3 : Full Vector space of degree 3 over GF(23)
U2 : Full Vector space of degree 4 over GF(23)
U1 : Full Vector space of degree 5 over GF(23)
U0 : Full Vector space of degree 6 over GF(23)
> 
> Valence(TS);
3
> Frame(TS);
[*
    Full Vector space of degree 3 over GF(23),

    Full Vector space of degree 4 over GF(23),

    Full Vector space of degree 5 over GF(23),

    Full Vector space of degree 6 over GF(23)
*]
> TensorCategory(TS);
Tensor category of Valence 3 (->,->,->,->) 
({ 1 },{ 2 },{ 0 },{ 3 })
> 
> Cat := TensorCategory([1,1,-1,-1],{{0},{1},{2},{3}});
> ChangeTensorCategory(~TS,Cat);
> TensorCategory(TS);
Tensor category of Valence 3 (->,->,<-,<-) 
({ 1 },{ 2 },{ 0 },{ 3 })
\end{code}

We construct the universal cotensor space of the symmetric cube, $S^3(V)$, of a vector space $V$.

\begin{code}
> V := VectorSpace( GF(3), 5 );
> S := SymmetricCotensorSpace(V,3);
> S;
Cotensor space of dimension 30 over GF(3) with valence 2
U3 : Full Vector space of degree 5 over GF(3)
U2 : Full Vector space of degree 5 over GF(3)
U1 : Full Vector space of degree 5 over GF(3)
> UniversalCotensorSpace(S);
Cotensor space of dimension 125 over GF(3) with valence 2
U3 : Full Vector space of degree 5 over GF(3)
U2 : Full Vector space of degree 5 over GF(3)
U1 : Full Vector space of degree 5 over GF(3)
> 
> IsSymmetric(S);
true
\end{code}
\end{example}

\chapter{Tensor categories}\label{ch:tensor-categories}

Magma allows tensors and tensor spaces to change categories. 
Unless a user specifies otherwise,
all tensors are assigned a category that is natural to the method
by which it was created.
For example a tensor created from an algebra will be assigned an 
algebra category, whereas a tensor created by structure constants
will be assigned the Albert homotopism category.  Tensor categories influence
the behavior of commands such as kernels and images  
as well as the algebraic invariants such as derivation algebras of a tensor.  

Our conventions follow \cite{Wilson:division}.  In particular given
a tensor $T$ framed by $[U_{v},\dots,U_0]$ then a tensor category for
$T$ will specify a function $A:\{0\dots v\}\to \{-1,0,1\}$ along with
a partition $\mathcal{P}$ of $\{0,\dots,v\}$ such that the following 
rules apply to the tensors and morphisms in the category.
\begin{enumerate}
\item for each tensor $T$ framed by $[U_v,\dots,U_0]$, if
$X\in\mathcal{P}$, then 
$$\forall i,j\in X,\quad U_i=U_j.$$

\item Given a second tensor $S$ framed by $[V_v,\dots,V_0]$,
a morphism $f:T\to S$ (Magma type {\tt Hmtp}) will be a list
$[f_v,\dots,f_0]$ of homomorphisms as follows:
\begin{itemize}
\item (Covariant) if $A(i)=1$ then $f_i:U_i\to V_i$;
\item (Constant) if $A(i)=0$ then $U_i=V_i$ and $f_i=1_{U_i}$; or else
\item (Contravariant) $A(i)=-1$ and $f_i:U_i\leftarrow V_i$.
\end{itemize}
So if $A(0)=1$ then
\begin{align*}
	\left\langle \sum_{i\in A^{-1}(1)} u_i f_i
		+\sum_{j\not\in A^{-1}(-1)} v_j\right\rangle_S
		& = \left\langle  \sum_{i\in A^{-1}(1)} u_i 
		+\sum_{j\not\in A^{-1}(-1)} v_j f_j\right\rangle_T f_0;
\end{align*}
if $A(0)=0$ then
\begin{align*}
	\left\langle \sum_{i\in A^{-1}(1)} u_i f_i
		+\sum_{j\not\in A^{-1}(-1)} v_j\right\rangle_S
		& = \left\langle  \sum_{i\in A^{-1}(1)} u_i 
		+\sum_{j\not\in A^{-1}(-1)} v_j f_j\right\rangle_T;
\end{align*}
else $A(0)=-1$ and 
\begin{align*}
	\left\langle \sum_{i\in A^{-1}(1)} u_i f_i
		+\sum_{j\not\in A^{-1}(-1)} v_j\right\rangle_S f_0
		& = \left\langle  \sum_{i\in A^{-1}(1)} u_i 
		+\sum_{j\not\in A^{-1}(-1)} v_j f_j\right\rangle_T.
\end{align*}
\end{enumerate}

Magma manages internally the differences between 
vectors and covectors and more generally tensors and cotensors.
Both types are issued the Magma type {\tt TenSpcElt}.
For operations sensitive to the difference, Magma stores a value of
co/contra-variance of the tensor as a property of the tensor category.
This the third general property stored in Magma's tensor category type
{\tt TenCat}.

We use the phrase tensor category exclusively for categories that describe tensors and tensor spaces.
In other words, the data structure of a tensor category is a function 
$A:\{0,\dots,v\}\rightarrow \{-1,0,1\}$ and a partition $P$ of $\{0,\dots,v\}$.
It is useful to distinguish from tensors and cotensors at the categorical level,
so a tensor category is either covariant or contravariant as well 
(in the latter case, referred to as a cotensor category).

\section{Creating tensor categories}~

\index{TensorCategory!constructor}
\begin{intrinsics}
TensorCategory(A, P) : [RngIntElt], {SetEnum} -> TenCat
TensorCategory(A, P) : Map, {SetEnum} -> TenCat
\end{intrinsics}

Sets up a covariant tensor space category with specified direction of
arrows $A$, and a partition $P$ indicating variables to be treated as
equivalent.  The fiber $A^{-1}(1)$ denotes the covariant variables,
$A^{-1}(0)$ identifies the constant variables, and $A^{-1}(-1)$ marks
the contra-variant variables.  

\index{CotensorCategory!constructor}
\begin{intrinsics}
CotensorCategory(A, P) : [RngIntElt], {SetEnum} -> TenCat
CotensorCategory(A, P) : Map, {SetEnum} -> TenCat
\end{intrinsics}

Sets up a contra-variant tensor space category with specified direction of
arrows $A$, and a partition $P$ indicating variables to be treated as
equivalent.  The fiber $A^{-1}(1)$ denotes the covariant variables,
$A^{-1}(0)$ identifies the constant variables, and $A^{-1}(-1)$ marks
the contra-variant variables.  

\index{HomotopismCategory}
\begin{intrinsics}
HomotopismCategory(v : parameters) : RngIntElt -> TenCat
    Contravariant : BoolElt : false
\end{intrinsics}

Returns Albert's homotopism category -- all modules categories are covariant 
and 
no duplicates considered.
Set the optional parameter {\tt Contravariant} to {\tt true} to make it a cotensor category.

\index{CohomotopismCategory}
\begin{intrinsics}
CohomotopismCategory(v) : RngIntElt -> TenCat
\end{intrinsics}

Returns the cohomotopism category -- all domain modules categories are 
covariant, the codomain is contravariant, and no duplicates considered.

\index{AdjointCategory}\index{LinearCategory}
\begin{intrinsics}
AdjointCategory(v, s, t) :  RngIntElt, RngIntElt, RngIntElt -> TenCat
LinearCategory(v, s, t) :  RngIntElt, RngIntElt, RngIntElt -> TenCat
\end{intrinsics}

Returns the tensor category where all modules are constant except in position 
$s$ and $t$.  Both $s$ and $t$ are in $\{0,\dots, v\}$.
Position $s$ is covariant, position $t$ is contravariant.

\begin{example}[TenCat\_Const]
We illustrate how to construct tensor categories.

\begin{code}
> Cat := TensorCategory([1,-1,0],{{0},{1},{2}});
> Cat;
Tensor category of Valence 2 (->,<-,==) ({ 1 },{ 2 },{ 0 })
> 
> TS := KTensorSpace(GF(5),[5,3,4],Cat);
> TS;
Tensor space of dimension 60 over GF(5) with valence 2
U2 : Full Vector space of degree 5 over GF(5)
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 4 over GF(5)
> TensorCategory(TS);
Tensor category of Valence 2 (->,<-,==) ({ 1 },{ 2 },{ 0 })
> 
> IsContravariant(TS);
false
\end{code}

All the tensor constructors that allow a {\tt TenCat} input can be used to make cotensors.

\begin{code}
> Cat := HomotopismCategory(2 : Contravariant := true);
> Cat;
Cotensor category of valence 2 (->,->) ({ 1 },{ 2 })
> T := Tensor(GF(5),[2,2],[1..4],Cat);
> T;
Cotensor of valence 1, U2 x U1 >-> K
U2 : Full Vector space of degree 2 over GF(5)
U1 : Full Vector space of degree 2 over GF(5)
\end{code}
\end{example}

\section{Operations on tensor categories}

We have basic operations for tensor categories.

\index{eq!tensor category}
\begin{intrinsics}
C1 eq C2 : TenCat, TenCat -> BoolElt
\end{intrinsics}

Decides if the tensor categories are the same.

\index{Valence!tensor category}
\begin{intrinsics}
Valence(C) : TenCat -> RngIntElt
\end{intrinsics}

Returns the valence of the tensor category.

\index{Arrows}
\begin{intrinsics}
Arrows(C) : TenCat -> SeqEnum
\end{intrinsics}

Returns the sequence of arrows of the tensor category. 
A $-1$ signifies an a contravariant index, a $0$ signifies a constant index, and a $1$ signifies a covariant index.

\index{RepeatPartition}
\begin{intrinsics}
RepeatPartition(C) : TenCat -> SetEnum
\end{intrinsics}

Returns the repeat partition for the tensor category.

\index{IsCovariant!tensor category}\index{IsContravariant!tensor category}
\begin{intrinsics}
IsCovariant(C) : TenCat -> BoolElt
IsContravariant(C) : TenCat -> BoolElt
\end{intrinsics}

Decides if the tensor category is covariant or contravariant.

\begin{example}[TenCat\_Prop]
We obtain basic properties of tensor categories.

\begin{code}
> C1 := TensorCategory([1,1,-1,1],{{0,3},{1},{2}});
> C1;
Tensor category of Valence 3 (->,->,<-,->) ({ 1 },{ 2 },
{ 0, 3 })
> 
> A := map< {0..3} -> {-1,0,1} | x :-> 1 >;
> C2 := TensorCategory(A,{{0..3}});
> C2;
Tensor category of Valence 3 (->,->,->,->) ({ 0 .. 3 })
> 
> C1 eq C2;
false
> RepeatPartition(C2);
{
    { 0 .. 3 }
}
> Valence(C2);
3
> Arrows(C2);
[ 1, 1, 1, 1 ]
\end{code}
\end{example}

\section{Categorical operations}

\subsection{Categorical operations on tensors}

We include functions defined for the category of tensors.
Most functions are currently defined only for Albert's homotopism category.

\index{Subtensor}
\begin{intrinsics}
Subtensor(T, S) : TenSpcElt, List -> TenSpcElt
\end{intrinsics}

Returns the smallest submap of $T$ containing $S$.

\index{Subtensor}
\begin{intrinsics}
Subtensor(T, D, C) : TenSpcElt, List, Any -> TenSpcElt
\end{intrinsics}

Returns the smallest submap of $T$ containing $D$ in the domain and $C$ in the 
codomain.

\index{IsSubtensor}
\begin{intrinsics}
IsSubtensor(T, S) : TenSpcElt, TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $S$ is a subtensor of $T$.

\index{LocalIdeal}
\begin{intrinsics}
LocalIdeal(T, S, I) : TenSpcElt, List, {RngIntElt} -> TenSpcElt
\end{intrinsics}

Returns the local ideal of $T$ at $I$ constaining $S$.

\index{LocalIdeal}
\begin{intrinsics}
LocalIdeal(T, D, C, I) : TenSpcElt, List, Any, {RngIntElt} -> TenSpcElt
\end{intrinsics}

Returns the local ideal of $T$ at $I$ constaining $D$ in the domain and $C$ 
in the codomain.

\index{LocalIdeal}
\begin{intrinsics}
LocalIdeal(T, S, I) : TenSpcElt, TenSpcElt, {RngIntElt} -> TenSpcElt
\end{intrinsics}

Returns the local ideal of $T$ at $I$ constaining $S$ as a submap.


\index{IsLocalIdeal}
\begin{intrinsics}
IsLocalIdeal(T, S, I) : TenSpcElt, TenSpcElt, {RngIntElt} -> BoolElt
\end{intrinsics}

Decides if $S$ is a local ideal of $T$ at $I$.

\index{Ideal}
\begin{intrinsics}
Ideal(T, S) : TenSpcElt, List -> TenSpcElt
\end{intrinsics}

Returns the ideal of $T$ containing $S$.

\index{Ideal}
\begin{intrinsics}
Ideal(T, D, C) : TenSpcElt, List, Any -> TenSpcElt
\end{intrinsics}

Returns the ideal of $T$ containing $D$ in the domain and $C$ in the codomain.

\index{Ideal}
\begin{intrinsics}
Ideal(T, S) : TenSpcElt, TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the ideal of $T$ containing $S$ as a submap.

\index{IsIdeal}
\begin{intrinsics}
IsIdeal(T, S) : TenSpcElt, TenSpcElt -> BoolElt
\end{intrinsics}

Decides if $S$ is an ideal of $T$.

\index{LocalQuotient}
\begin{intrinsics}
LocalQuotient(T, S, I : parameters) : TenSpcElt, TenSpcElt, {RngIntElt} -> TenSpcElt, Hmtp
    Check : BoolElt : true
\end{intrinsics}

Returns the local quotient of $T$ by $S$ at $I$. If you know $S$ is a local 
ideal of $T$ at $I$, set {\tt Check} to {\tt false} to skip the verification.
A homotopism is also returned, mapping from $T$ to $T/S$.

\index{Quotient!tensor}\index{/!tensor}
\begin{intrinsics}
Quotient(T, S : parameters) : TenSpcElt, TenSpcElt -> TenSpcElt, Hmtp
    Check : BoolElt : true
T / S : TenSpcElt, TenSpcElt -> TenSpcElt, Hmtp
\end{intrinsics}

Returns the quotient of $T$ by $S$. If you know $S$ is an ideal of $T$, 
set {\tt Check} to {\tt false} to skip the verification.
A homotopism is also returned, mapping from $T$ to $T/S$.

\begin{example}[Ten\_Cat\_Ops]
We will construct a quotient of tensors. First, we construct a subtensor from a random tensor.

\begin{code}
> T := RandomTensor(GF(5),[4,4,2]);
> T := RandomTensor(GF(5),[4,4,2]);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 2 over GF(5)
> 
> F := Frame(T);
> L := [* F[1]![1,1,1,0], F[2]![0,0,0,1], F[3]![0,0] *];
> S := Subtensor(T,L);
> S;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(1 1 1 0)
Echelonized basis:
(1 1 1 0)
U1 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(0 0 0 1)
Echelonized basis:
(0 0 0 1)
U0 : Vector space of degree 2, dimension 1 over GF(5)
Generators:
(0 2)
Echelonized basis:
(0 1)
> 
> IsSubtensor(T,S);
true
\end{code}

Now we construct the ideal of $T$ containing $S$.

\begin{code}
> I := Ideal(T,S);
> I;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(1 1 1 0)
Echelonized basis:
(1 1 1 0)
U1 : Vector space of degree 4, dimension 1 over GF(5)
Generators:
(0 0 0 1)
Echelonized basis:
(0 0 0 1)
U0 : Full Vector space of degree 2 over GF(5)
Generators:
(1 0)
(0 1)
> 
> IsIdeal(T,I);
true
\end{code}

Finally, we construct the quotient of $T$ by $I$.

\begin{code}
> T/I;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(5)
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 0 over GF(5)
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: Mapping from: Full Vector space of degree 4 over 
GF(5) to Full Vector space of degree 3 over GF(5)
U1 -> V1: Mapping from: Full Vector space of degree 4 over 
GF(5) to Full Vector space of degree 3 over GF(5)
U0 -> V0: Mapping from: Full Vector space of degree 2 over 
GF(5) to Full Vector space of degree 0 over GF(5)
\end{code}
\end{example}

\subsection{Categorical operations on tensor spaces}

We have categorical notions for tensor spaces as well.

\index{SubConstructor!tensor space}\index{sub!tensor space}
\begin{intrinsics}
SubConstructor(T, L) : TenSpc, Any -> TenSpc, Map
sub< T | L > : TenSpc, Any -> TenSpc, Map
\end{intrinsics}

Returns the subtensor space of $T$ generated by the tensors in the sequence $L$.

%\index{SubtensorSpace}
%\begin{intrinsics}
%SubtensorSpace(T, L) : TenSpc, [TenSpcElt] -> TenSpc
%\end{intrinsics}

%Returns the subtensor space of $T$ generated by the tensors in the sequence $L$.

%\index{SubtensorSpace}
%\begin{intrinsics}
%SubtensorSpace(T, t) : TenSpc, TenSpcelt -> TenSpc
%\end{intrinsics}

%Returns the subtensor space of $T$ generated by the tensor $t$.

\index{IsSubtensorSpace}
\begin{intrinsics}
IsSubtensorSpace(T, S) : TenSpc, TenSpc -> BoolElt
\end{intrinsics}

Decides if the tensor space $S$ is a subtensor space of $T$.

\index{QuoConstructor!tensor space}\index{quo!tensor space}\index{/!tensor space}
\begin{intrinsics}
QuoConstructor(T, S) : TenSpc, TenSpc -> TenSpc, Map
quo< T | S > : TenSpc, TenSpc -> TenSpc, Map
T / S : TenSpc, TenSpc -> TenSpc, Map
\end{intrinsics}

Returns the quotient tensor space of $T$ by $S$.

\begin{example}[TenSpc\_Cat\_Ops]
We construct a subtensor space.

\begin{code}
> T := KTensorSpace(GF(2),[4,4,2]);
> T;
Tensor space of dimension 32 over GF(2) with valence 2
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> 
> L := [ T.i : i in [1..Ngens(T)] | IsEven(i) ];
> S := SubtensorSpace(T, L);
> S;
Tensor space of dimension 16 over GF(2) with valence 2
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> SystemOfForms(Random(S));
[
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0],

    [1 0 0 0]
    [0 1 0 1]
    [1 0 0 0]
    [0 0 1 0]
]
\end{code}

Now we compute the quotient tensor space $Q=T/S$.

\begin{code}
> Q := T/S;
> Q;
Tensor space of dimension 16 over GF(2) with valence 2
U2 : Full Vector space of degree 4 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 2 over GF(2)
> SystemOfForms(Random(Q));
[
    [0 0 0 0]
    [1 1 1 0]
    [1 0 1 1]
    [1 1 0 1],

    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
]
> SystemOfForms(Q![1 : i in [1..32]]);
[
    [1 1 1 1]
    [1 1 1 1]
    [1 1 1 1]
    [1 1 1 1],

    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 0]
]
\end{code}
\end{example}

\section{Homotopisms}

Magma provides functions for homotopisms. Homotopisms are also equipped with a tensor category.

\subsection{Constructions of Homotopisms}~

\index{Homotopism}
\begin{intrinsics}
Homotopism(T, S, M : parameters) : TenSpcElt, TenSpcElt, List -> Hmtp
    Check : BoolElt
Homotopism(T, S, M, C : parameters) : TenSpcElt, TenSpcElt, List, TenCat -> Hmtp
    Check : BoolElt
\end{intrinsics}

Returns the homotopism from $T$ to $S$ given by the list of maps $M$ and the category $C$. 
The default tensor category is the same as tensor categories for $T$ and $S$.

\begin{example}[Hmtp\_Const]
We illustrate how to construct tensor categories.

\begin{code}
> TS := KTensorSpace(GF(4),[2,3,4]);
> T := Random(TS);
> S := Random(TS);
> M := [* Random(KMatrixSpace(GF(4),i,i)) : i in [2..4] *];
> H := Homotopism(T,S,M);
> H;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[    1     0]
[    0     0]
U1 -> V1: 
[    0   $.1 $.1^2]
[    1     1   $.1]
[  $.1   $.1 $.1^2]
U0 -> V0: 
[    1     1   $.1 $.1^2]
[    0     1 $.1^2   $.1]
[    0     0   $.1 $.1^2]
[  $.1 $.1^2   $.1     0]
> 
> 
> M[2] := map< Frame(TS)[2] -> Frame(TS)[2] | x :-> x >;
> H2 := Homotopism(T,S,M);
> H2;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[    1     0]
[    0     0]
U1 -> V1: Mapping from: Full Vector space of degree 3 
over GF(2^2) to Full Vector space of degree 3 over GF(2^2) 
given by a rule [no inverse]
U0 -> V0: 
[    1     1   $.1 $.1^2]
[    0     1 $.1^2   $.1]
[    0     0   $.1 $.1^2]
[  $.1 $.1^2   $.1     0]
\end{code}
\end{example}


\subsection{Basic Operations with Homotopisms}

We provide some operations for homotopisms.

\index{$*$!homotopism}
\begin{intrinsics}
H1 * H2 : Hmtp, Hmtp -> Hmtp
\end{intrinsics}

Returns the composition of the homotopisms $H_1$ and $H_2$.

\index{Domain!homotopism}
\begin{intrinsics}
Domain(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the domain tensor of $H$.

\index{Codomain!homotopism}
\begin{intrinsics}
Codomain(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the codomain tensor of $H$.

\index{Maps}
\begin{intrinsics}
Maps(H) : Hmtp -> List
\end{intrinsics}

Returns the list of maps for the various modules in the domain and codomain 
tensors.

\index{.!homotopisms}
\begin{intrinsics}
H.i : Hmtp, RngIntElt -> Map
\end{intrinsics}

Returns the map on the $i$th coordinate.

\index{TensorCategory!homotopism}
\begin{intrinsics}
TensorCategory(H) : Hmtp -> TenCat
\end{intrinsics}

Returns the tensor category of $H$.

\index{ChangeTensorCategory!homotopism}
\begin{intrinsics}
ChangeTensorCategory(H, C) : Hmtp, TenCat -> Hmtp
ChangeTensorCategory(~H, C) : Hmtp, TenCat -> Hmtp
\end{intrinsics}

Changes the tensor category of $H$ to the given category.

\index{Kernel}
\begin{intrinsics}
Kernel(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the kernel of $H$ as an ideal of its domain tensor.

\index{Image!homotopism}
\begin{intrinsics}
Image(H) : Hmtp -> TenSpcElt
\end{intrinsics}

Returns the image of $H$ as a submap of the codomain tensor.

\begin{example}[Hmtp\_Ops]
We perform basic operations with homotopisms.

\begin{code}
> T := RandomTensor(GF(7),[5,4,3]);
> F := Frame(T);
> 
> I := [* hom< F[j] -> F[j] | [< F[j].i,F[j].i > :\
>   i in [1..Dimension(F[j])]] > : j in [1..3] *];
> H := Homotopism(T,T,I);
> 
> Image(H);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 5 over GF(7)
U1 : Full Vector space of degree 4 over GF(7)
U0 : Full Vector space of degree 3 over GF(7)
> Kernel(H);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 5, dimension 0 over GF(7)
U1 : Vector space of degree 4, dimension 0 over GF(7)
U0 : Vector space of degree 3, dimension 0 over GF(7)
\end{code}

If the tensor is over vector spaces, then matrices can be used to create a homotopism.

\begin{code}
> M := [* RandomMatrix(GF(7),i,i) : i in [5,4,3] *];
> G := Homotopism(T,T,M);
> G;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[5 3 6 0 4]
[6 0 0 1 1]
[6 4 3 1 5]
[3 4 6 1 4]
[2 4 1 3 2]
U1 -> V1: 
[5 5 0 3]
[3 5 1 3]
[3 6 1 5]
[2 3 5 4]
U0 -> V0: 
[6 4 1]
[2 6 5]
[1 2 3]
\end{code}

Homotopisms can be composed so long as Magma can compose each of the individual maps.

\begin{code}
> G*G;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[3 6 3 0 5]
[0 5 1 4 2]
[1 5 0 2 1]
[2 4 4 2 2]
[4 2 0 0 5]
U1 -> V1: 
[4 3 6 0]
[4 6 0 6]
[4 3 4 3]
[0 4 0 0]
U0 -> V0: 
[3 1 1]
[1 5 5]
[6 1 6]
\end{code}

We can change the underlying category for the homotopism $G$ to get a different morphism.

\begin{code}
> Cat := TensorCategory([1,-1,1],{{0},{1},{2}});
> G := Homotopism(T,T,M,Cat);
> G;
Maps from U2 x U1 >-> U0 to V2 x V1 >-> V0.
U2 -> V2: 
[5 3 6 0 4]
[6 0 0 1 1]
[6 4 3 1 5]
[3 4 6 1 4]
[2 4 1 3 2]
U1 <- V1: 
[5 5 0 3]
[3 5 1 3]
[3 6 1 5]
[2 3 5 4]
U0 -> V0: 
[6 4 1]
[2 6 5]
[1 2 3]
> 
> Image(G);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 5 over GF(7)
U1 : Vector space of degree 4, dimension 0 over GF(7)
U0 : Vector space of degree 3, dimension 2 over GF(7)
Echelonized basis:
(1 0 4)
(0 1 3)
> 
> Kernel(G);
Tensor of valence 2, U2 x U1 >-> U0
U2 : Vector space of degree 5, dimension 0 over GF(7)
U1 : Full Vector space of degree 4 over GF(7)
U0 : Vector space of degree 3, dimension 1 over GF(7)
Echelonized basis:
(1 4 0)
\end{code}
\end{example}

