
Tensors are required to have the following information.
\begin{itemize}
\item A commutative ring $K$ of coefficients.
\item A valence $v$ indicating the number of variables to include in its 
associated multilinear map.
\item A list $[U_v,\dots, U_0]$ of $K$-modules called the {\em frame}.
\item A function $U_v\times \cdots \times U_1\to U_0$ that is $K$-linear in 
each $U_i$.
\end{itemize}
Tensors have type {\tt TenSpcElt} and are formally elements of a tensor space 
(type {\tt TenSpc}).  By default a tensor's parent space is a universal tensor space:
\begin{align*}
	\hom_K(U_v,\dots,\hom_K(U_1,U_0)\cdots) \cong \hom_K(U_v\otimes_K\cdots \otimes_K U_1,U_0).
\end{align*}
The left hand module is used primarily as it avoids the need to work with 
the equivalence classes of a tensor product.
Operations such as linear combinations of tensors take place within a  
tensor space.
Attributes such as coefficients, valence, and frame  apply to the tensor space 
as well.

When necessary, the user may further direct the operations on tensors to 
appropriate tensor categories 
(type {\tt TenCat}).  For instance covariant and contravariant variables can 
be specified
as well as imposing symmetry conditions.  If no tensor category is prescribed
then a default tensor category is used based on the method of creation.
\medskip

\minitoc

\section{Creating tensors}

\subsection{Black-box tensors}
A user can specify a tensor by a black-box function that evaluates the required
multilinear map.

\index{Tensor!black-box}
\begin{intrinsics}
Tensor(S, F) : SeqEnum, UserProgram -> TenSpcElt, List
Tensor(S, F) : List, UserProgram -> TenSpcElt, List
Tensor(S, F, Cat) : SeqEnum, UserProgram, TenCat -> TenSpcElt, List
Tensor(S, F, Cat) : List, UserProgram, TenCat -> TenSpcElt, List
\end{intrinsics}

Returns a tensor $T$ and a list of maps from the given frame into vector spaces of the returned frame.
$T$ is a tensor over vector spaces---essentially forgetting all other structure.
The last entry of {\tt S} is assumed to be the codomain of the multilinear map. 
The user-defined function $F$ should take as input a tuple of elements of the domain and return an element of the codomain.
If no tensor category is provided, the Albert's homotopism category is used.

\begin{example}[BBTensorsFrame]
We demonstrate the black-box constructions by first constructing the dot product $\cdot : \mathbb{Q}^4\times \mathbb{Q}^4\rightarrowtail \mathbb{Q}$.
The function used to evaluate our black-box tensor, {\tt Dot}, must take exactly one argument.
The argument will be a {\tt Tup}, an element of the Cartesian product $U_v\times \cdots\times U_1$.
Note that {\tt x[i]} is the $i$th entry in the tuple and not the $i$th coordinate.
\begin{code}
> Q := Rationals();
> U := VectorSpace(Q, 4);
> V := VectorSpace(Q, 4);
> W := VectorSpace(Q, 1);  // Vector space, not the field Q
> Dot := func< x | x[1]*Matrix(4, 1, Eltseq(x[2])) >;
\end{code}

Now we will construct the tensor from the data above.
The first object returned is the tensor, and the second is a list of maps, mapping the given frame into the vector space frame.
In this example, since the given frame consists of vector spaces, these maps are trivial.
Note that the list of maps are not needed to work with the given tensor, we will demonstrate this later. 
\begin{code}
> Tensor([U, V, W], Dot);
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
[*
    Mapping from: ModTupFld: U to ModTupFld: U given by a rule,
    Mapping from: ModTupFld: U to ModTupFld: U given by a rule,
    Mapping from: ModTupFld: W to ModTupFld: W given by a rule
*]
\end{code}

We will provide a tensor category for the dot product tensor, so that the returned tensor is not in the default homotopism category. 
We will use instead the $21$-adjoint category.
While the returned tensor prints out the same as above, it does indeed live in a universe.
The details of tensor categories are discussed in Chapter~\ref{ch:tensor-categories}.
\begin{code}
> Cat := AdjointCategory(3, 2, 1);
> Cat;
Tensor category of valence 3 (<-,->,==) ({ 1 },{ 2 },{ 0 })
> 
> t := Tensor([U, V, W], Dot, Cat);
> t;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over Rational Field
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
> 
> TensorCategory(t);
Tensor category of valence 3 (<-,->,==) ({ 1 },{ 2 },{ 0 })
\end{code}
\end{example}

\begin{example}[BBCrossProduct]

We will construct the cross product $\times : \mathbb{R}^3\times \mathbb{R}^3\rightarrowtail \mathbb{R}^3$ and verify that ${\bf i}\times {\bf j} = {\bf k}$.
However, to do this test, we will input integer sequences (specifically {\tt [RngIntElt]}), and we will still be able to evaluate.
\begin{code}
> K := RealField(5);
> V := VectorSpace(K, 3);
> CP := function(x)
function>   return V![x[1][2]*x[2][3] - x[1][3]*x[2][2], \
function|return>     x[1][3]*x[2][1] - x[1][1]*x[2][3], \
function|return>     x[1][1]*x[2][2] - x[1][2]*x[2][1] ];
function> end function;
> T := Tensor([V, V, V], CP);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over Real field of precision 5
U1 : Full Vector space of degree 3 over Real field of precision 5
U0 : Full Vector space of degree 3 over Real field of precision 5
> 
> // test that i x j = k
> <[1,0,0], [0,1,0]> @ T eq V.3;
true
\end{code}
\end{example}

\index{Tensor!black-box}
\begin{intrinsics}
Tensor(D, C, F) : SeqEnum, Any, UserProgram -> TenSpcElt, List
Tensor(D, C, F) : List, Any, UserProgram -> TenSpcElt, List
Tensor(D, C, F, Cat) : SeqEnum, Any, UserProgram, TenCat -> TenSpcElt, List
Tensor(D, C, F, Cat) : List, Any, UserProgram, TenCat -> TenSpcElt, List
\end{intrinsics}

Returns a tensor $T$ and a list of maps from the given frame into vector spaces of the returned frame.
$T$ is a tensor over vector spaces---essentially forgetting all other structure.
The user-defined function $F$ should take as input a tuple of elements of $D$ and return an element of $C$.
If no tensor category is provided, the Albert's homotopism category is used.

\begin{example}[BBTripleProduct]
Tensors make it easy to create algebras that do not fit into traditional categories, such as algebras with triple products.
Here, we create a triple product $\langle \,\rangle : \mathbb{M}_{2\times 3}(K)\times \mathbb{M}_{2\times 3}(K)\times\mathbb{M}_{2\times 3}(K)\rightarrowtail \mathbb{M}_{2\times 3}(K)$, given by $\langle A, B, C\rangle = AB^tC$.

\begin{code}
> K := GF(541);
> U := KMatrixSpace(K,2,3);
> my_prod := func< x | x[1]*Transpose(x[2])*x[3] >;
> T := Tensor([U,U,U,U], my_prod );
> T;
Tensor of valence 4, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 6 over GF(541)
U2 : Full Vector space of degree 6 over GF(541)
U1 : Full Vector space of degree 6 over GF(541)
U0 : Full Vector space of degree 6 over GF(541)
\end{code}

Notice that the returned tensor is over vector spaces instead of the universe of {\tt KMatrixSpace}.
Tensors can still evaluate elements from the given frame, even though it prints out over vector spaces. 
However, the returned value form the tensor will be in the codomain of the tensor, so in this case, $K^6$.
\begin{code}
> A := U![1,0,0,0,0,0];
> A;
[  1   0   0]
[  0   0   0]
> 
> <A,A,A>@T;  // A is a generalized idempotent
(  1   0   0   0   0   0)
\end{code}

We can experiment to see if this triple product is left associative.
To do this, we will construct five random matrices $\{ X_1,\dots,X_5\}\subset \mathbb{M}_{2\times 3}(K)$, and then we test if 
\[ \langle \langle X_1, X_2, X_3 \rangle, X_4, X_5\rangle = \langle X_1, \langle X_4, X_3, X_2\rangle, X_5\rangle. \]
Observe that the tuples have mixed entries, one from $K^6$ and two others from $\mathbb{M}_{2\times 3}(K)$. 

\begin{code}
> X := [Random(U) : i  in [1..5]];
> X;
[
    [485 378 385]
    [241 505 134],

    [141 531 245]
    [472 484 339],

    [377  85 170]
    [451 522 334],

    [211 340 409]
    [ 95 349 128],

    [264 372 144]
    [205  47 428]
]
> 
> A := <X[1],X[2],X[3]>@T;
> B := <X[4],X[3],X[2]>@T;
> A, B;
(460 436 181 341 134 404)
(465 420 458 421 291 225)
> 
> <A, X[4], X[5]> @ T eq <X[1], B, X[5]> @ T;
true
\end{code}

To confirm this product is left associative, we can create a new tensor for the left triple-associator and see that its image is $0$.
We will create a $6$-tensor $\{ \, \} : \prod_{k=1}^5 \mathbb{M}_{2\times 3}(K)\rightarrowtail \mathbb{M}_{2\times 3}(K)$ where
\[ \lla X_1,\dots, X_5\rra = \langle \langle X_1, X_2, X_3 \rangle, X_4, X_5\rangle - \langle X_1, \langle X_4, X_3, X_2\rangle, X_5\rangle. \]
Therefore, if im$(\lla \, \rra)=0$, then $\langle \,\rangle$ is left associative. 

\begin{code}
> l_asct := func< X | Eltseq(<<X[1], X[2], X[3]> @ T, X[4], X[5]> @ T \
>     - <X[1], <X[4], X[3], X[2]> @ T, X[5]> @ T) >;
> LT := Tensor([* U : i in [0..5] *], l_asct);
> LT;
Tensor of valence 6, U5 x U4 x U3 x U2 x U1 >-> U0
U5 : Full Vector space of degree 6 over GF(541)
U4 : Full Vector space of degree 6 over GF(541)
U3 : Full Vector space of degree 6 over GF(541)
U2 : Full Vector space of degree 6 over GF(541)
U1 : Full Vector space of degree 6 over GF(541)
U0 : Full Vector space of degree 6 over GF(541)
> 
> I := Image(LT);
> I;
Vector space of degree 6, dimension 0 over GF(541)
Generators:

> 
> Dimension(I);
0
\end{code}

Observe that in {\tt l\_asct} the function {\tt Eltseq} is called. 
This is because {\tt T} returns vectors in $K^6$ which is not naturally coercible by Magma into $\mathbb{M}_{2\times 3}(K)$. 
On the other hand, sequences can be coerced into $\mathbb{M}_{2\times 3}(K)$. 
\end{example}




\subsection{Tensors with structure constant sequences}
Most computations with tensors $T$ will be carried out using structure constants
$T_{j_v\cdots j_0}\in K$.  Here $T$ is framed by free $K$-modules $[U_v,\dots,U_0]$ 
with each $U_i$ having an ordered bases $\mathcal{B}_i=[e_{i1},\dots,e_{id_i}]$.
The interpretation of structure constants is that the associated multilinear function 
$[x_v,\dots,x_1]$ from $U_v\times \cdots \times U_1$ into $U_0$ is determined on 
bases as follows:
\begin{align*}
	[e_{vj_v},\dots,e_{1j_1} ]& = \sum_{k=1}^{d_0} T_{j_v \cdots j_0} e_{0k}.
\end{align*}
Structure constants are input and stored as sequences $S$ in $K$ according to the
following assignment. Set $f:\mathbb{Z}^{v+1}\to \mathbb{Z}$ to be:
\begin{align*}
		 f(j_v,\dots,j_0) & = 1+\sum_{s=0}^v (j_s-1)\prod_{t=0}^{s-1} d_t.
\end{align*}
So $S[f(j_v,\dots,j_0)]=T_{j_v\cdots j_0}$ specifies the structure constants as a sequence.  
\smallskip

\noindent{\bf Notes.}
\begin{itemize}
\item Magma does not presently support the notion of a sparse sequence of structure constants.
A user can provide this functionality by specifying a tensor with a user program rather
than structure constants. 

\item Some routines in Magma require structure constant sequences.  If they 
are not provided, Magma may compute and store a structure constant representation
inside the tensor.

\item We do not separate structure constant indices that are contravariant.  Instead contravariant variables are signaled by tensor categories.  So Ricci styled tensors $T_{a_p\cdots a_1}^{b_q\cdots b_1}$ should be input as $T_{a_{p+q}\cdots a_{1+q} b_q\cdots b_1}$ and the tensor
category changed to mark $\{q..1\}$ as contravariant. Intrinsics are provided to facilitate this approach.
See Chapter~\ref{ch:tensor-categories} for more details on tensor categories.
\end{itemize}
\medskip

\index{Tensor!structure constants}
\begin{intrinsics}
Tensor(D, S) : [RngElt], SeqEnum -> TenSpcElt
Tensor(R, D, S) : Rng, [RngElt], SeqEnum -> TenSpcElt
Tensor(D, S, Cat) : [RngElt], SeqEnum, TenCat -> TenSpcElt
Tensor(R, D, S, Cat) : Rng, [RngElt], SeqEnum, TenCat -> TenSpcElt
\end{intrinsics}

Given dimensions $D=[d_v,\dots,d_0]$, returns the tensor
in $R^{d_v\cdots d_0}$ identified by structure constant sequence $S$.
If $R$ is not provided then the parent ring of the first element of $S$ is used.  
$R$ must be a commutative unital ring.
The default tensor category $Cat$ is the homotopism category.


\begin{example}[SCTensors]

We will create structure constants sequence with all 0s and one 1 that occurs in the first entry.
First, we will input this along with the dimensions of the tensor we are after, $2\times 2\times 2$. 
However, since we did not specify a ring, it is assumed to be the parent ring of the first entry of the structure constants sequence.
In this example, the ring is $\mathbb{Z}$. 

\begin{code}
> sc := [ 0 : i in [1..8] ];
> sc[1] := 1;
> Tensor([2, 2, 2], sc);
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full RSpace of degree 2 over Integer Ring
U1 : Full RSpace of degree 2 over Integer Ring
U0 : Full RSpace of degree 2 over Integer Ring
\end{code}

We do not want the underlying ring to be $\mathbb{Z}$, so we will input the ring we want: GF$(64)$.
\begin{code}
> K := GF(64);
> T := Tensor(K, [2, 2, 2], sc);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(2^6)
U1 : Full Vector space of degree 2 over GF(2^6)
U0 : Full Vector space of degree 2 over GF(2^6)
> 
> Image(T);
Vector space of degree 2, dimension 1 over GF(2^6)
Generators:
(     1      0)
Echelonized basis:
(     1      0)
\end{code}

We can recover the structure constants by calling {\tt StructureConstants} or {\tt Eltseq}.
We will also test that the tensor evaluates inputs correctly.
\begin{code}
> StructureConstants(T);
[ 1, 0, 0, 0, 0, 0, 0, 0 ]
> 
> <[1, 0], [K.1^3, 0]> @ T;
( K.1^3      0)
> 
> <[K.1^29, 1], [0, K.1^2]> @ T;
(     0      0)
\end{code}
\end{example}


\index{StructureConstants}\index{Eltseq}
\begin{intrinsics}
StructureConstants(T) : TenSpcElt -> SeqEnum
Eltseq(T) : TenSpcElt -> SeqEnum
\end{intrinsics}

Returns the sequence of structure constants of the given tensor $T$. 


\begin{example}[SCFromBBTensors]

We will construct the natural Lie module action for $\mathfrak{sl}_2$, but we will construct it as a \emph{left} module. 
To do this, we construct a function that takes elements from $\mathfrak{sl}_2\times V$ and returns an element that Magma can coerce into $V$. 
We run a quick test to make sure our function runs on the trivial example; this is the only check the intrinsic runs on black-box tensors. 
Since $\mathfrak{sl}_2$ and $V$ are part of different universes in Magma, we must use the {\tt List} environment when constructing this black-box tensor. 

\begin{code}
> sl2 := MatrixLieAlgebra("A1", GF(7));
> V := VectorSpace(GF(7), 2);
> left_action := func< x | x[2]*Transpose(Matrix(x[1])) >;
> left_action(<sl2!0, V!0>);
(0 0)
> 
> sl2 := MatrixLieAlgebra("A1", GF(7));
> V := VectorSpace(GF(7), 2);
> left_action := func< x | x[2]*Transpose(Matrix(x[1])) >;
> left_action(<sl2!0, V!0>);
(0 0)
> 
> T := Tensor([* sl2, V, V *], left_action);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(7)
U1 : Full Vector space of degree 2 over GF(7)
U0 : Full Vector space of degree 2 over GF(7)
\end{code}

Now we will extract the structure constants from this Lie module action. 
We will then construct a tensor with these structure constants and compare it with our first tensor above.

\begin{code}
> StructureConstants(T);
[ 1, 0, 0, 6, 0, 0, 1, 0, 0, 1, 0, 0 ]
> 
> S := Tensor([3, 2, 2], Eltseq(T));
> S;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(7)
U1 : Full Vector space of degree 2 over GF(7)
U0 : Full Vector space of degree 2 over GF(7)
> 
> T eq S;
true
\end{code}
\end{example}


\begin{example}[SCStored]

The structure constants are convenient data structure for nearly all the algorithms in eMAGma. 
In fact, most computations require structure constants, so we store the structure constants sequence with the tensor. 
This means that after the initial structure constant sequence computation, every time {\tt StructureConstants} or {\tt Eltseq} is called, Magma retreives what was previously computed. 

We will demonstrate this on a large black-box example, so some time is spent computing the structure constants. 
Of course, the exact timing will vary by machine.
We will construct a product of two subalgebras of $\mathbb{M}_{20}(\mathbb{F}_3)$, namely $* : \mathfrak{sl}_{20}(\mathbb{F}_3)\times \mathbb{M}_4(\mathbb{F}_3)\rightarrowtail \mathbb{M}_{20}(\mathbb{F}_3)$.

\begin{code}
> sl20 := MatrixLieAlgebra("A19", GF(3));
> M4 := MatrixAlgebra(GF(3), 4);
> Prod := func< x | Matrix(x[1])*DiagonalJoin(<x[2] : i in [1..5]>) >;
> T := Tensor([* sl20, M4 *], MatrixAlgebra(GF(3), 20), Prod);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 399 over GF(3)
U1 : Full Vector space of degree 16 over GF(3)
U0 : Full Vector space of degree 400 over GF(3)
\end{code}

We record the time it takes to initially compute the structure constants sequence, and then we record the time when we call the function again.
\begin{code}
> time sc := StructureConstants(T);
Time: 58.670
> 
> time sc := StructureConstants(T);
Time: 0.000
\end{code}
\end{example}





\subsection{Bilinear tensors}
A special case of structure constants for bilinear maps $U_2\times U_1\rightarrowtail U_0$
is to format the data as lists of matrices $[M_1,\dots, M_a]$.
This can be considered as a left (resp. right) representation
$U_2\to \hom_K(U_1,U_0)$, (resp. $U_1\to \hom_K(U_2,U_0)$).  
Or it can be treated as {\em systems of bilinear forms} 
$[M_1,\dots,M_a]$ where the matrices are the Gram matrices of bilinear forms $\phi_i:U_2\times U_1\rightarrowtail K$.
Here the associated bilinear map $U_2\times U_1\rightarrowtail U_0$ is 
specified by
\begin{align*}
	(u_2,u_1) & \mapsto ( \phi_1(u_2,u_1),\dots, \phi_a(u_2,u_1)).
\end{align*}

\index{Tensor!bilinear}\index{Tensor!forms}
\begin{intrinsics}
Tensor(M, s, t) : Mtrx, RngIntElt, RngIntElt -> TenSpcElt 
Tensor(M, s, t, C) : Mtrx, RngIntElt, RngIntElt, TenCat -> TenSpcElt
Tensor(M, s, t) : [Mtrx], RngIntElt, RngIntElt -> TenSpcElt 
Tensor(M, s, t, C) : [Mtrx], RngIntElt, RngIntElt, TenCat -> TenSpcElt
\end{intrinsics}

Returns the bilinear tensor given by the list of matrices.  The interpretation
of the matrices as structure constants is specified by the coordinates $s$ and $t$
which must be positions in $\{2,1,0\}$.  Optionally a tensor category $C$ can be assigned.


\begin{example}[SymplecticForm]

We will construct a symplectic bilinear form on $V=K^8$. 
It would be cumbersome to construct this tensor as a black-box tensor or by providing the structure constants sequence. 
Instead, we will provide a (Gram) matrix. 
\begin{code}
> K := GF(17);
> MS := KMatrixSpace(K, 2, 2);
> J := KroneckerProduct(IdentityMatrix(K, 4), MS![0, 1, -1, 0]);
> J;
[ 0  1  0  0  0  0  0  0]
[16  0  0  0  0  0  0  0]
[ 0  0  0  1  0  0  0  0]
[ 0  0 16  0  0  0  0  0]
[ 0  0  0  0  0  1  0  0]
[ 0  0  0  0 16  0  0  0]
[ 0  0  0  0  0  0  0  1]
[ 0  0  0  0  0  0 16  0]
> 
> T := Tensor(J, 2, 1);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 8 over GF(17)
U1 : Full Vector space of degree 8 over GF(17)
U0 : Full Vector space of degree 1 over GF(17)
> 
> IsAlternating(T);
true
\end{code}

Now we will construct the symplectic form using the black-box construction and verify that the two tensors are the same. 
\begin{code}
> V := VectorSpace(K, 8);
> symp := func< x | x[1]*J*Matrix(8, 1, Eltseq(x[2])) >;
> S := Tensor([V, V], VectorSpace(K, 1), symp);
> S;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 8 over GF(17)
U1 : Full Vector space of degree 8 over GF(17)
U0 : Full Vector space of degree 1 over GF(17)
> 
> SystemOfForms(S);
[
    [ 0  1  0  0  0  0  0  0]
    [16  0  0  0  0  0  0  0]
    [ 0  0  0  1  0  0  0  0]
    [ 0  0 16  0  0  0  0  0]
    [ 0  0  0  0  0  1  0  0]
    [ 0  0  0  0 16  0  0  0]
    [ 0  0  0  0  0  0  0  1]
    [ 0  0  0  0  0  0 16  0]
]
\end{code}
\end{example}

\index{AsMatrices}\index{SystemOfForms}
\begin{intrinsics}
AsMatrices(T, s, t) : TenSpcElt, RngIntElt, RngIntElt -> SeqEnum
SystemOfForms(T) : TenSpcElt -> SeqEnum
\end{intrinsics}

For a tensor $T$ with frame $[K^{d_v},\dots,K^{d_0}]$, 
returns a list $[M_1,\dots,M_d]$, $d=(d_v\cdots d_0)/d_s d_t$, 
of $(d_s\times d_t)$-matrices in $K$ representing the tensor
as an element of $\hom_K(K^{d_s}\otimes_K K^{d_t},K^d)$.
For {\tt SystemOfForms}, $T$ must have valence $3$ and the implied values
are $s=2$ and $t=1$.


\begin{example}[TrilinearAsMats]

We construct the associator of $\mathfrak{sl}_2(\mathbb{Q})$ where $\langle \, \rangle : \prod_{k=1}^3\mathfrak{sl}_2\rightarrowtail \mathfrak{sl}_2$ given by
\[ \langle x,y,z \rangle = [[x,y],z] - [x,[y,z]]. \]
It can be hard to understand some of the features of this trilinear map by only looking at the structure constants sequence. 
The function {\tt AsMatrices} slices the sequence asnd presents the data as a sequence of matrices.
\begin{code}
> K := Rationals();
> L := LieAlgebra("A1", K);
> T := AssociatorTensor(L);
> T;
Tensor of valence 4, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 3 over Rational Field
U2 : Full Vector space of degree 3 over Rational Field
U1 : Full Vector space of degree 3 over Rational Field
U0 : Full Vector space of degree 3 over Rational Field
>
> Eltseq(T);
[ 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2,
0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 2, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0,
2, 0, 0, 0, 0, 0, 0, 0, -2, 0, 0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0 ]
\end{code}

Calling {\tt AsMatrices(T, 3, 1)} returns a sequence of nine matrices, but we only show the first four.
As explained in the documentation above, this sequence of matrices can be interpreted as the system of bilinear forms for the 3-tensor $\circ_{31} : V_3 \times V_1 \rightarrowtail \Hom_K(V_2,V_0)$ given by
\[ x\circ_{31} z = \langle x, -,z \rangle = [[x,-],z] - [x,[-,z]].\]

\begin{code}
> AsMatrices(T, 3, 1)[1..4];
[
    [ 0  0  2]
    [ 0  0  0]
    [-2  0  0],

    [ 0  0  0]
    [ 0  0  2]
    [ 0 -2  0],

    [0 0 0]
    [0 0 0]
    [0 0 0],

    [ 0  1  0]
    [-1  0  0]
    [ 0  0  0]
]
\end{code}
\end{example}



\subsection{Tensors from algebraic objects}
A natural and important source of tensors come from algebraic object with a distributive property.
One main source is from algebras, where $*:A\times A\rightarrowtail A$ is given by multiplication in $A$. 
Like with the previous sections on tensor constructions, all tensors will be constructed over vector spaces. 
The user can still input elements from the original algebra, but map(s) will also be returned.
Furthermore, each tensor is assigned a category relevant to its origin, see Chapter~\ref{ch:tensor-categories} for more details on tensor categories. 


\index{Tensor!algebra}\index{Tensor!polynomial ring}
\begin{intrinsics}
Tensor(A) : Alg -> TenSpcElt, Map
Tensor(A) : RngUPolRes -> TenSpcElt, Map
\end{intrinsics}

Returns the bilinear tensor given by the product in $A$.

\begin{example}[D4LieAlgebra]

We want to get the Lie bracket from $D_4(11)$. 
Tensors created from algebras will have a homotopism category, but with $U_2=U_1=U_0$. 
This forces the operators acting to be the same on all the coordinates; in other words, $\Omega=\End(U_2)$ instead of $\Omega=\End(U_2)\times\End(U_1)\times\End(U_0)$. 
\begin{code}
> D := DerivationAlgebra(T);
> L := LieAlgebra("D4", GF(11));
> T := Tensor(L);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 28 over GF(11)
U1 : Full Vector space of degree 28 over GF(11)
U0 : Full Vector space of degree 28 over GF(11)
> IsAlternating(T);
true
> TensorCategory(T);
Tensor category of valence 3 (->,->,->) ({ 0, 1, 2 })
\end{code}

If we compute the derivation algebra of $L$, our operators will act in the same way on each coordinate.
This is the standard definition of the derivation algebra of a ring.
\begin{code}
> D := DerivationAlgebra(T);
> Dimension(D);
28
> SemisimpleType(D);
D4
\end{code}

Now we will change the category to the standard homotopism category, where we do \emph{not} ``fuse'' $U_2$, $U_1$, and $U_0$. 
\begin{code}
> ChangeTensorCategory(~T, HomotopismCategory(3));
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 28 over GF(11)
U1 : Full Vector space of degree 28 over GF(11)
U0 : Full Vector space of degree 28 over GF(11)
> TensorCategory(T);
Tensor category of valence 3 (->,->,->) ({ 1 },{ 2 },{ 0 })
\end{code}

We compare the same computation of derivation algebra. 
This time, the theory tells us that there will be a solvable radical.
In this example, Rad$(D)=K^2$. 
\begin{code}
> D := DerivationAlgebra(T);
> Dimension(D);
30
> R := SolvableRadical(D);
> SemisimpleType(D/R);
D4
\end{code}
\end{example}

\begin{example}[WittAlgebra]

The Witt algebra, over a finite field of characteristic $p$, is isomorphic to the derivation algebra of $K[x]/(x^p)$.
The Witt algebra is a simple Lie algebra with dimension $p$ and a trivial Killing form.
First, we will construct the tensor from the ring $\mathbb{F}_5[x]/(x^5)$.
Note that, like with algebras, the tensor category will ``fuse'' $U_2$, $U_1$, and $U_0$, so that the operators act the same way on every coordinate.
\begin{code}
> p := 5;
> R<x> := PolynomialRing(GF(p));
> I := ideal< R | x^p >;
> Q := quo< R | I >;
> Q;
Univariate Quotient Polynomial Algebra in $.1 over Finite field of size
5 with modulus $.1^5
> T := Tensor(Q);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 5 over GF(5)
U1 : Full Vector space of degree 5 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
> TensorCategory(T);
Tensor category of valence 3 (->,->,->) ({ 0, 1, 2 })
\end{code}

Now we will construct a Lie representation of the Witt algebra from the tensor {\tt T}. 
\begin{code}
> D := DerivationAlgebra(T);
> IsSimple(D);
true
> Dimension(D);
5
> KillingForm(D);
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
\end{code}
\end{example}


\index{CommutatorTensor}\index{AnticommutatorTensor}
\begin{intrinsics}
CommutatorTensor(A) : Alg -> TenSpcElt, Map
AnticommutatorTensor(A) : Alg -> TenSpcElt, Map
\end{intrinsics}

Returns the bilinear commutator map $[a,b]=ab-ba$ or the anticommutator map $\langle a,b\rangle = ab+ba$ of the algebra $A$.
This should not be used to get the tensor given by the Lie or Jordan product in a Lie or Jordan algebra; instead use {\tt Tensor}.

\begin{example}[CommutatorFromAlgebra]

We will construct the commutator tensor from $\mathbb{M}_4(\mathbb{Q})$. 
\begin{code}
> A := MatrixAlgebra(Rationals(), 4);
> C := CommutatorTensor(A);
> C;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 16 over Rational Field
U1 : Full Vector space of degree 16 over Rational Field
U0 : Full Vector space of degree 16 over Rational Field
> IsAlternating(C); // [X, X] = 0?
true
\end{code}

With this tensor, we will compute the dimension of the centralizer of the diagonal matrix $M$ with diagonal entries $(1,1,-1,-1)$ in $\mathbb{M}_4(\mathbb{Q})$. 
To do this, we will subtract the dimension of the image of $[M, A]$ from the dimension of $A$. 

\begin{code}
> M := A![1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,-1];
> M;
[ 1  0  0  0]
[ 0  1  0  0]
[ 0  0 -1  0]
[ 0  0  0 -1]
> Dimension(A) - Dimension(<M, A> @ C);
8
\end{code}
\end{example}

\begin{example}[MatrixJordanAlgebra]
This time, we will obtain a Jordan product from $\mathbb{M}_4(\mathbb{Q})$. 
That is, we will construct the bilinear map $* : \mathbb{M}_4(\mathbb{Q})\times \mathbb{M}_4(\mathbb{Q})\rightarrowtail \mathbb{M}_4(\mathbb{Q})$ where $A*B = \frac{1}{2}(AB+BA)$. 
\begin{code}
> A := MatrixAlgebra(Rationals(), 4);
> J := AnticommutatorTensor(A);
> J;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 16 over Rational Field
U1 : Full Vector space of degree 16 over Rational Field
U0 : Full Vector space of degree 16 over Rational Field
> SystemOfForms(J)[1];
[2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0]
[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
> A.1*J*A.1;
(2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
\end{code}

From the documentation on {\tt AnticommutatorTensor}, we have to scale our tensor above {\tt J} by $1/2$ to get what we want.
Of course this won't affect the proceeding tests though.
\begin{code}
> T := (1/2)*J;
> A.1*T*A.1;
(1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
\end{code}

Now we will confirm that {\tt T} is a Jordan product. 
First, we check that {\tt T} is commutative, and then we check that it satisfies the Jordan identity: $(xy)(xx)=x(y(xx))$.
\begin{code}
> IsSymmetric(T);
true
> JordanID := func< x, y | (x*T*y)*T*(x*T*x) - x*T*(y*T*(x*T*x)) >;
> forall{ <x,y> : x in Basis(A), y in Basis(A) | \
>     JordanIdentity(x, y) eq Codomain(T)!0 };
true
\end{code}
\end{example}

\index{AssociatorTensor}
\begin{intrinsics}
AssociatorTensor(A) : Alg -> TenSpcElt, Map
\end{intrinsics}

Returns the trilinear associator map $[a,b,c]=(ab)c-a(bc)$ of the algebra $A$.

\begin{example}[AssociatorFromAlgebra]

Do three random octonions associate? Hardly ever.

\begin{code}
> O := OctonionAlgebra(GF(1223),-1,-1,-1);
> T := AssociatorTensor(O);
> T;
Tensor of valence 4, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 8 over GF(1223)
U2 : Full Vector space of degree 8 over GF(1223)
U1 : Full Vector space of degree 8 over GF(1223)
U0 : Full Vector space of degree 8 over GF(1223)
> <Random(O),Random(O),Random(O)> @ T eq O!0;
false
\end{code}

However, for all $a,b\in\mathbb{O}$, $(aa)b=a(ab)$ as octonions are alternative algebras.

\begin{code}
> a := Random(O); 
> b := Random(O); 
> <a,a,b> @ T eq O!0;
true
> IsAlternating(T);
true
\end{code}
\end{example}


\index{pCentralTensor}
\begin{intrinsics}
pCentralTensor(G, p, s, t) : Grp, RngIntElt, RngIntElt, RngIntElt -> TenSpcElt, List
pCentralTensor(G, s, t) : Grp, RngIntElt, RngIntElt -> TenSpcElt, List
pCentralTensor(G) : Grp -> TenSpcElt, List
\end{intrinsics}

Returns the bilinear map of commutation from the associated graded Lie algebra of the lower exponent-$p$ central
series $\eta$ of $G$.  The bilinear map pairs $\eta_s/\eta_{s+1}$ with $
\eta_{t}/\eta_{t+1}$ into $\eta_{s+t}/\eta_{s+t+1}$.  If $s=t$ the tensor 
category is set to force $U_2=U_1$; 
otherwise it is the general homotopism category.
In addition, maps from the subgroups into the vector spaces are returned as a list. 
If $p$, $s$, and $t$ are not given, it is assumed $G$ is a $p$-group and $s=t=1$.

\begin{example}[TensorPGroup]
Groups have a single binary operation. So even when groups are built from
rings it can be difficult to recover the ring from the group operations. 
Tensors supply one approach for that task.
We will get the $p$-central tensor of $G=\SL(3,125)$; however, we will lose the fact that there is a field $\mathbb{F}_{125}$. 
The tensor we will get back is $[,] : K^6\times K^6 \rightarrowtail K^3$, where $K=\mathbb{F}_5$. 

\begin{code}
> P := ClassicalSylow(SL(3,125),5);
> Q := PCGroup(P); // Loose track of GF(125).
> Q;
GrpPC : Q of order 1953125 = 5^9
PC-Relations:
    Q.4^Q.1 = Q.4 * Q.7^4, 
    Q.4^Q.2 = Q.4 * Q.8^4, 
    Q.4^Q.3 = Q.4 * Q.9^4, 
    Q.5^Q.1 = Q.5 * Q.8^4, 
    Q.5^Q.2 = Q.5 * Q.9^4, 
    Q.5^Q.3 = Q.5 * Q.7^3 * Q.8^3, 
    Q.6^Q.1 = Q.6 * Q.9^4, 
    Q.6^Q.2 = Q.6 * Q.7^3 * Q.8^3, 
    Q.6^Q.3 = Q.6 * Q.8^3 * Q.9^3
> T := pCentralTensor(Q);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 6 over GF(5)
U1 : Full Vector space of degree 6 over GF(5)
U0 : Full Vector space of degree 3 over GF(5)
\end{code}

Knowing that $G$ is defined over $\mathbb{F}_{125}$, we know that the commutator is really just the alternating form $\cdot : \mathbb{F}_{125}^2\times \mathbb{F}_{125}^2\rightarrowtail \mathbb{F}_{125}$.
This information can be extracted from the centroid of {\tt T} above, and we can rewrite {\tt T} over the field $\mathbb{F}_{125}$.
\begin{code}
> F := Centroid(T); // Recover GF(125)
> Dimension(F);
3
> IsSimple(F);
true
> IsCommutative(F);
true
> S := TensorOverCentroid(T);
> S;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(5^3)
U1 : Full Vector space of degree 2 over GF(5^3)
U0 : Full Vector space of degree 1 over GF(5^3)
\end{code}
\end{example}

\index{Polarisation}\index{Polarization}
\begin{intrinsics}
Polarisation(f) : MPolElt -> TenSpcElt, MPolElt
Polarisation(f) : RngUPolElt -> TenSpcElt, MPolElt
Polarization(f) : MPolElt -> TenSpcElt, MPolElt
Polarization(f) : RngUPolElt -> TenSpcElt, MPolElt
\end{intrinsics}

Returns the polarization of the homogeneous multivariate polynomial (or univariate polynomial) $f$ as a tensor and as a multivariate polynomial. 
Polarization does \emph{not} normalize by $1/d!$, where $d$ is the degree of $f$.  

\begin{example}[TensorPolarization]
We polarize the polynomial $f(x,y)=x^2y$. 
Because $f$ is homogeneous of degree 3 with 2 variables, we expect that the polarization will have 6 variables and that the corresponding mulilinear form will be $K^2\times K^2\times K^2\rightarrowtail K$.
The polarization of $f$ is given by $P(x_1,x_2,y_1,y_2,z_1,z_2 ) = 2 (x_1y_1z_2 + x_1y_2z_1 + x_2y_1z_1)$.

\begin{code}
> R<x,y> := PolynomialRing(Rationals(),2);
> T, p := Polarization(x^2*y);
> p;
2*$.1*$.3*$.6 + 2*$.1*$.4*$.5 + 2*$.2*$.3*$.5
> T;
Tensor of valence 4, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 2 over Rational Field
U2 : Full Vector space of degree 2 over Rational Field
U1 : Full Vector space of degree 2 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
> <[1,0],[1,0],[1,0]> @ T;
(0)
> <[1,0],[1,0],[0,1]> @ T;
(2)
\end{code} %$% editer does not recognize the custom environment
\end{example}


\subsection{New tensors from old}
We can construct new tensors from old.

\index{AlternatingTensor}
\begin{intrinsics}
AlternatingTensor(T) : TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the alternating tensor induced by the given tensor. If 
the tensor is already alternating, then the given tensor is returned.

\index{AntisymmetricTensor}
\begin{intrinsics}
AntisymmetricTensor(T) : TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the antisymmetric tensor induced by the given tensor. If 
the tensor is already antisymmetric, then the given tensor is returned.

\index{SymmetricTensor}
\begin{intrinsics}
SymmetricTensor(T) : TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the symmetric tensor induced by the given tensor. If the tensor is 
already symmetric, then the given tensor is returned.

\begin{example}[AlternatingTensor]

Tensors coming from Lie algebras are alternating.
If we call {\tt AlternatingTensor} on a tensor from a Lie algebra, nothing will be changed.
\begin{code}
> L := LieAlgebra("A3", GF(3));
> T := Tensor(L);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 15 over GF(3)
U1 : Full Vector space of degree 15 over GF(3)
U0 : Full Vector space of degree 15 over GF(3)
> AlternatingTensor(T) eq T;
true
\end{code}
\end{example}

\begin{example}[MakeSymmetric]

We will make the tensor coming from the product in $\mathbb{M}_3(\mathbb{Q})$ symmetric.
\begin{code}
> A := MatrixAlgebra(Rationals(), 3);
> T := Tensor(A);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 9 over Rational Field
U1 : Full Vector space of degree 9 over Rational Field
U0 : Full Vector space of degree 9 over Rational Field
> SystemOfForms(T)[1];
[1 0 0 0 0 0 0 0 0]
[0 0 0 1 0 0 0 0 0]
[0 0 0 0 0 0 1 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
\end{code}

We see that the first matrix in the sequence of bilinear forms of {\tt T} is not symmetric, so {\tt T} is not symmetric (of course matrix multiplcation is not commutative also). 
We will construct a symmetric version of {\tt T} and inspect the first matrix of the bilinear forms.
\begin{code}
> S := SymmetricTensor(T);
> S;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 9 over Rational Field
U1 : Full Vector space of degree 9 over Rational Field
U0 : Full Vector space of degree 9 over Rational Field
> SystemOfForms(S)[1];
[2 0 0 0 0 0 0 0 0]
[0 0 0 1 0 0 0 0 0]
[0 0 0 0 0 0 1 0 0]
[0 1 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 1 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0]
\end{code}
\end{example}


\index{Shuffle}
\begin{intrinsics}
Shuffle(T, g) : TenSpcElt, GrpPermElt -> TenSpcElt
Shuffle(T, g) : TenSpcElt, SeqEnum -> TenSpcElt
\end{intrinsics}

For a tensor $T$ in $\hom(U_{\vav},\dots,\hom(U_1,U_0)\cdots)$, 
generates a representation of $T$ in 
\[ \hom(U_{v^g},\dots,\hom(U_{1^g},U_{0^g})\dots). \]
In order to be defined, $g\in\text{Sym}(\{0..v\})$. 
If $0^g\ne 0$, then both the image and pre-image of $0$ under $g$ will be replaced by their $K$-dual space.
For cotensors, $g\in\text{Sym}(\{1..v\})$.
Sequences $[a_1,\dots,a_{\vav+1}]$ will be interpreted as 
\[ \begin{array}{cccc} 0 & 1 & \cdots & \vav \\ \downarrow & \downarrow & & \downarrow \\ a_1 & a_2 & \cdots & a_{\vav+1}. \end{array}\]

\begin{example}[ShuffleToTranspose]

We will shuffle the alternating form $\mathbb{Q}^2\times\mathbb{Q}^2\rightarrowtail \mathbb{Q}$ as a means of performing a transpose on the Gram matrix.
To do this, we need to shuffle by the transposition $(1, 2)$ in Sym$(\{0,1,2\})$. 
\begin{code}
> T := Tensor(Rationals(), [2, 2, 1], [0, 1, -1, 0]);
> T;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over Rational Field
U1 : Full Vector space of degree 2 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
> SystemOfForms(T);
[
    [ 0  1]
    [-1  0]
]
> 
> S := Shuffle(T, [0,2,1]);
> S;
Tensor of valence 3, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over Rational Field
U1 : Full Vector space of degree 2 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
> SystemOfForms(S);
[
    [ 0 -1]
    [ 1  0]
]
\end{code}
\end{example}

\begin{example}[Shuffling]

We will generate a random 5-tensor and shuffle it with $(0,2,4,1,3)$.
\begin{code}
> T := RandomTensor(GF(2), [5,4,3,2,1]);
> T;
Tensor of valence 5, U4 x U3 x U2 x U1 >-> U0
U4 : Full Vector space of degree 5 over GF(2)
U3 : Full Vector space of degree 4 over GF(2)
U2 : Full Vector space of degree 3 over GF(2)
U1 : Full Vector space of degree 2 over GF(2)
U0 : Full Vector space of degree 1 over GF(2)
> 
> G := Sym({0..4});
> g := G![2, 3, 4, 0, 1];
> g;
(0, 2, 4, 1, 3)
> 
> S := Shuffle(T, g);
> S;
Tensor of valence 5, U4 x U3 x U2 x U1 >-> U0
U4 : Full Vector space of degree 2 over GF(2)
U3 : Full Vector space of degree 1 over GF(2)
U2 : Full Vector space of degree 5 over GF(2)
U1 : Full Vector space of degree 4 over GF(2)
U0 : Full Vector space of degree 3 over GF(2)
\end{code}
\end{example}




\section{Operations with Tensors}

We take two perspectives for operations with tensors. 
First, tensors determine multilinear maps and so behave as
functions.  Second, tensors are elements of a tensor space and 
so behave as elements in a module.  

\subsection{Elementary operations}
Treating the tensor space as a $K$-module, we have the standard operations.

\index{$+$}\index{$*$!as module}
\begin{intrinsics}
S + T : TenSpcElt, TenSpcElt -> TenSpcElt
k * T : RngElt, TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the sum or scalar multiple of tensors as module elements of the tensor 
space. The corresponding multilinear maps are the sum or scalar multiple of the 
multilinear maps.

%\index{TensorOnVectorSpaces}
%\begin{intrinsics}
%TensorOnVectorSpaces(T) : TenSpcElt -> TenSpcElt, Hmtp
%\end{intrinsics}

%Returns the tensor on vector spaces and an isotopism from the given tensor. 
%This is a forgetful functor that forces all domain and codomain terms to be 
%vector spaces.

\index{AssociatedForm}
\begin{intrinsics}
AssociatedForm(T) : TenSpcElt -> TenSpcElt
\end{intrinsics}

For a tensor $T$ with multilinear maps $U_v\times \cdots \times U_1\rightarrowtail U_0$,
creates the associated multilinear form
$U_v\times\cdots\times U_1\times U_0^*\rightarrowtail K$.  The valence is increased
by $1$.

\index{Compress}
\begin{intrinsics}
Compress(T) : TenSpcElt -> TenSpcElt
\end{intrinsics}

Returns the compression of the tensor. This removes all 1-dimensional spaces 
in the domain.

\begin{example}[Ten\_VS\_Cmp]
We construct the tensor of a Lie algebra given by multiplication. 
We apply the forgetful functor to forget the algebra structure and and just leave vector spaces.
However, we can still evaluate Lie algebra elements with this new tensor on vector spaces.

\begin{code}
> L := LieAlgebra("D4",GF(5));
> T := Tensor(L); 
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Lie Algebra of dimension 28 with base ring GF(5)
U1 : Lie Algebra of dimension 28 with base ring GF(5)
U0 : Lie Algebra of dimension 28 with base ring GF(5)
> <L.2,L.11> @ T;
(1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
> 
> S := TensorOnVectorSpaces(T);
> S;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 28 over GF(5)
U1 : Full Vector space of degree 28 over GF(5)
U0 : Full Vector space of degree 28 over GF(5)
> V := Domain(S)[1];
> <L.2,L.11> @ S eq <V.2,V.11> @ S;
true
\end{code}

Now we compute the associated form to $S$ to get a trilinear map. 
We shuffle it by the permutation $(0,3)$ and compress it.
The result is just the shuffle of the original bilinear map $S$ by $(0,2,1)$.

\begin{code}
> AF := AssociatedForm(S);
> AF;
Tensor of valence 3, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 28 over GF(5)
U2 : Full Vector space of degree 28 over GF(5)
U1 : Full Vector space of degree 28 over GF(5)
U0 : Full Vector space of degree 1 over GF(5)
> Eltseq(AF) eq Eltseq(S);
true
> 
> <L.2,L.11,L.1> @ AF;
(1)
> <L.2,L.11,L.2 > @ AF;
(0)
> 
> U := Shuffle(AF,[3,1,2,0]);
> U;
Tensor of valence 3, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 1 over GF(5)
U2 : Full Vector space of degree 28 over GF(5)
U1 : Full Vector space of degree 28 over GF(5)
U0 : Full Vector space of degree 28 over GF(5)
> 
> Cmp := Compress(U);
> Shf := Shuffle(S,[2,0,1]);
> Cmp eq Shf;
true
\end{code}
\end{example}

\subsection{General properties}~

\index{Parent!tensor}
\begin{intrinsics}
Parent(T) : TenSpcElt -> TenSpc
\end{intrinsics}

Returns the tensor space that contains $T$. The default space is the universal 
tensor space.

\index{Domain!tensor}
\begin{intrinsics}
Domain(T) : TenSpcElt -> List
\end{intrinsics}

Returns the domain of the tensor as a list of modules.

\index{Codomain!tensor}
\begin{intrinsics}
Codomain(T) : TenSpcElt -> Any
\end{intrinsics}

Returns the codomain of the tensor.

\index{Valence!tensor}
\begin{intrinsics}
Valence(T) : TenSpcElt -> RngIntElt
\end{intrinsics}

Returns the valence of the tensor.

\index{Frame!tensor}
\begin{intrinsics}
Frame(T) : TenSpcElt -> List
\end{intrinsics}

Returns the modules in the frame of $T$; this is the concatenation of
the domain modules and the codomain.

\index{TensorCategory!tensor}
\begin{intrinsics}
TensorCategory(T) : TenSpcElt -> TenCat
\end{intrinsics}

Returns the underlying tensor category of $T$.

\index{ChangeTensorCategory!tensor}
\begin{intrinsics}
ChangeTensorCategory(T, C) : TenSpcElt, TenCat -> TenSpcElt
ChangeTensorCategory(~T, C) : TenSpcElt, TenCat
\end{intrinsics}

Returns the tensor with the given category.

\index{IsCovariant!tensor}\index{IsContravariant!tensor}
\begin{intrinsics}
IsCovariant(T) : TenSpcElt -> BoolElt
IsContravariant(T) : TenSpcElt -> BoolElt
\end{intrinsics}

Decides if the underlying category of $T$ is covariant or contravariant.

\begin{example}[Ten\_Prop1]
We demonstrate how to extract basic properties of a tensor.

\begin{code}
> T := RandomTensor(GF(3),[3,4,5,6]);
> T;
Tensor of valence 3, U3 x U2 x U1 >-> U0
U3 : Full Vector space of degree 3 over GF(3)
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 5 over GF(3)
U0 : Full Vector space of degree 6 over GF(3)
> Valence(T);
3
> 
> BaseRing(T);
Finite field of size 3
> 
> Frame(T);
[*
    Full Vector space of degree 3 over GF(3),

    Full Vector space of degree 4 over GF(3),

    Full Vector space of degree 5 over GF(3),

    Full Vector space of degree 6 over GF(3)
*]
> 
> Domain(T);
[*
    Full Vector space of degree 3 over GF(3),

    Full Vector space of degree 4 over GF(3),

    Full Vector space of degree 5 over GF(3)
*]
> 
> Codomain(T);
Full Vector space of degree 6 over GF(3)
> 
> Parent(T); // Universal tensor space
Tensor space of dimension 360 over GF(3) with valence 3
U3 : Full Vector space of degree 3 over GF(3)
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 5 over GF(3)
U0 : Full Vector space of degree 6 over GF(3)
> 
> TensorCategory(T);
Tensor category of Valence 3 (->,->,->,->) ({ 1 },{ 2 },{ 0 },{ 3 })
> 
> Cat := TensorCategory([-1,-1,1,1],{{i} : i in [0..3]});
> ChangeTensorCategory(~T, Cat);
> TensorCategory(T);
Tensor category of Valence 3 (<-,<-,->,->) ({ 1 },{ 2 },{ 0 },{ 3 })
\end{code}
\end{example}

\index{Image!tensor}
\begin{intrinsics}
Image(T) : TenSpcElt -> ModTupRng, Map
\end{intrinsics}

Returns the (categorical) image of the tensor along with a map to the vector space.
Thus, if the type of the codomain of $T$ is not {\tt ModTupRng}, the returned map
is an isomorphism from the codomain of $T$ to the free $R$-module $R^{d_0}$. 

\index{BaseRing!tensor}\index{BaseField!tensor}
\begin{intrinsics}
BaseRing(T) : TenSpcElt -> Rng
BaseField(T) : TenSpcElt -> Fld
\end{intrinsics}

Returns the base ring or field of the tensor.

\index{NondegenerateTensor}
\begin{intrinsics}
NondegenerateTensor(T) : TenSpcElt -> TenSpcElt, Hmtp
\end{intrinsics}

Returns the nondegenerate multilinear map associated to $T$ along with a homotopism 
from the given tensor to the returned nondegenerate tensor.

\index{IsNondegenerate}
\begin{intrinsics}
IsNondegenerate(T) : TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $T$ is a nondegenerate multilinear map.

\index{FullyNondegenerateTensor}
\begin{intrinsics}
FullyNondegenerateTensor(T) : TenSpcElt -> TenSpcElt, Hmtp
\end{intrinsics}

Returns the fully nondegenerate multilinear map associated to $T$ along with a
cohomotopism from the given tensor to the returned tensor.

\index{IsFullyNondegenerate}
\begin{intrinsics}
IsFullyNondegenerate(T) : TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $T$ is a fully nondegenerate multilinear map.

\index{IsAlternating!tensor}\index{IsAntisymmetric!tensor}
\begin{intrinsics}
IsAlternating(T) : TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $T$ is an alternating tensor.

\index{IsAntisymmetric!tensor}
\begin{intrinsics}
IsAntisymmetric(T) : TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $T$ is an antisymmetric tensor.

\index{IsSymmetric!tensor}
\begin{intrinsics}
IsSymmetric(T) : TenSpcElt -> BoolElt
\end{intrinsics}

Decides whether $T$ is a symmetric tensor.

\begin{example}[Ten\_Prop2]
We demonstrate how to extract basic properties of a tensor.

\begin{code}
> J := Matrix(GF(9),[[0,1,-1],[1,-1,-1],[-1,-1,1]]);
> M := DiagonalJoin(J,ZeroMatrix(GF(9),3,3));
> M;
[    0     1     2     0     0     0]
[    1     2     2     0     0     0]
[    2     2     1     0     0     0]
[    0     0     0     0     0     0]
[    0     0     0     0     0     0]
[    0     0     0     0     0     0]
> 
> T := Tensor([M,-M],2,1);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 6 over GF(3^2)
U1 : Full Vector space of degree 6 over GF(3^2)
U0 : Full Vector space of degree 2 over GF(3^2)
> 
> Image(T);
Vector space of degree 2, dimension 1 over GF(3^2)
Generators:
(    1     2)
Echelonized basis:
(    1     2)
Mapping from: Full Vector space of degree 2 over GF(3^2) to 
Full Vector space of degree 2 over GF(3^2) given by a rule
> 
> Radical(T);
<
    Vector space of degree 6, dimension 3 over GF(3^2)
    Echelonized basis:
    (    0     0     0     1     0     0)
    (    0     0     0     0     1     0)
    (    0     0     0     0     0     1),

    Vector space of degree 6, dimension 3 over GF(3^2)
    Echelonized basis:
    (    0     0     0     1     0     0)
    (    0     0     0     0     1     0)
    (    0     0     0     0     0     1)
>
\end{code}

The tensor we built above is degenerate because it has a nontrivial radical. 
We will construct the nondegenerate tensor as well as the fully nondegenerate tensor.

\begin{code}
> ND := NondegenerateTensor(T);
> ND;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(3^2)
U1 : Full Vector space of degree 3 over GF(3^2)
U0 : Full Vector space of degree 2 over GF(3^2)
> 
> FN := FullyNondegenerateTensor(T);
> FN;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 3 over GF(3^2)
U1 : Full Vector space of degree 3 over GF(3^2)
U0 : Vector space of degree 2, dimension 1 over GF(3^2)
Generators:
(    1     2)
Echelonized basis:
(    1     2)
\end{code}
\end{example}

\subsection{As multilinear maps}
Regarding tensors as multilinear maps, we allow for composition and evaluation.

\index{AT}
\begin{intrinsics}
x @ T : Tup, TenSpcElt -> Any
\end{intrinsics}

Evaluates the tensor $T$ at $x\in U_v\times \cdots \times U_1$.

\index{$*$!as multilinear map}
\begin{intrinsics}
T * f : TenSpcElt, Map -> TenSpcElt
\end{intrinsics}

Returns the tensor which is the composition of $T$ with the given map $f$.

\index{eq!tensor}
\begin{intrinsics}
S eq T : TenSpcElt, TenSpcElt -> BoolElt
\end{intrinsics}

Decides if the tensors are the same multilinear map.

\subsection{Operations with Bilinear maps}
Tensors of valence $2$, also known as bilinear tensors, or
as bilinear maps,  are commonly described as distributive products.
For instance as the product of an algebra, the product of a ring on 
a module, or an inner product.  We supports this interpretation 
by permitting an infix $x*y$ notation for the evaluation of bilinear
tensors.  We support this by creating special types 
{\tt BmpU[Elt]}, {\tt BmpV[Elt]}, and {\tt BmpW[Elt]} for the frame
of a bilinear tensor.


\index{$*$!bilinear (product)}
\begin{intrinsics}
x * y : BmpUElt, BmpVElt -> Any
x * y : BmpU, BmpV -> Any
x * y : BmpUElt, BmpV -> Any
x * y : BmpU, BmpVElt -> Any
\end{intrinsics}

If $x$ and $y$ are associated to the bilinear map $B$, these operations return 
{\tt <x,y> @ B}.

\index{$*$!bilinear (infix)}
\begin{intrinsics}
x * B : Any, TenSpcElt -> TenSpcElt
B * y : Any, TenSpcElt -> TenSpcElt
\end{intrinsics}

Given a bilinear tensor $B$ framed by $[U_2,U_1,U_0]$,
$x*B$ returns the action on the right as a 
linear map $L : U_1\rightarrow U_0$ given 
by $vL = x* v$ if $x$ is an element of $U_2$. 
If $x$ is a subspace of $U_2$, then this returns a sequence of 
maps one for each element in the basis for $x$.
For the land-hand action use $B*y$ instead.
If $B$ is valence 1, then the image of either $x$ or $y$ is returned.

\index{Parent!bilinear}
\begin{intrinsics}
Parent(x) : BmpUElt -> BmpU
Parent(x) : BmpVElt -> BmpV
\end{intrinsics}

Returns the parent space of the bilinear map element.

\index{Parent!bilinear}
\begin{intrinsics}
Parent(X) : BmpU -> TenSpcElt
Parent(X) : BmpV -> TenSpcElt
\end{intrinsics}

Returns the original bilinear map where these spaces came from.

\index{LeftDomain}
\begin{intrinsics}
LeftDomain(B) : TenSpcElt -> BmpU
\end{intrinsics}

Returns the left domain, $U_2$, of $B$ framed by $[U_2,U_1,U_0]$, 
setup for use with infix notation.

\index{RightDomain}
\begin{intrinsics}
RightDomain(B) : TenSpcElt -> BmpV
\end{intrinsics}

Returns the right domain, $U_1$, of $B$  framed by $[U_2,U_1,U_0]$. 
setup for use with infix notation.

\index{IsCoercible!bilinear}\index{BANG!bilinear}
\begin{intrinsics}
IsCoercible(S,x) : BmpU, Any -> BoolElt, BmpUElt
IsCoercible(S,x) : BmpV, Any -> BoolElt, BmpVElt
S!x : BmpU, Any -> BoolElt, BmpUElt
S!x : BmpV, Any -> BoolElt, BmpVElt
\end{intrinsics}

Decides if $x$ can be coerced into $S$, and if it can, it returns the coerced 
element.

\index{eq!bilinear}
\begin{intrinsics}
u1 eq u2 : BmpUElt, BmpUElt -> BoolElt
v1 eq v2 : BmpUElt, BmpUElt -> BoolElt
U1 eq U2 : BmpU, BmpU -> BoolElt
V1 eq V2 : BmpV, BmpV -> BoolElt
\end{intrinsics}

Decides if the elements or spaces are equal.

\begin{example}[Bimap\_Infix]
We demonstrate the infix product using tensors of valence 2. 
If $B : U_2\times U_1\rightarrowtail U_0$ is a tensor, then for $x\in U_2$, we get a valence 1 tensor $x*B : U_1\rightarrow U_0$.
Similarly, for $y\in U_1$, we get $B*y : U_2\rightarrow U_0$. Furthermore, one can write $x*B*y$ to get $<x,y> @B$.

\begin{code}
> B := RandomTensor(GF(5),[4,3,5]);
> B;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
> [3,2,0,1]*B*[1,1,2];
(2 1 1 3 4)
> [1,0,0,0]*B;
Tensor of valence 1, U1 >-> U0
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
> B*[0,2,0];
Tensor of valence 1, U1 >-> U0
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
\end{code}
\end{example}

\begin{example}[Bimap\_Product]
We demonstrate the product notation for tensors of valence 2 using a tensor derived from a group. 
Suppose $G$ is a $p$-group and $B : U_2\times U_1\rightarrowtail U_0$ is the tensor given by commutation where $U_2=U_1=G/\Phi(G)$ and $U_0$ is the next factor of the exponent-$p$ central series of $G$.

\begin{code}
> G := SmallGroup(512,10^6);
> B := pCentralTensor(G,2,1,1);
> B;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 5 over GF(2)
U1 : Full Vector space of degree 5 over GF(2)
U0 : Full Vector space of degree 4 over GF(2)
> U := LeftDomain(B);   //U2
> V := RightDomain(B);  //U1
> U![0,1,0,1,0] * V![1,0,0,0,0];
(1 0 0 1)
> U!(G.2*G.4) * V!G.1;
(1 0 0 1)
\end{code}

This notation can be used to evaluate subspaces.

\begin{code}
> H := sub< G | G.2,G.4 >;
> U!H * V!G.1;
Vector space of degree 4, dimension 2 over GF(2)
Generators:
(0 0 0 1)
(1 0 0 0)
Echelonized basis:
(1 0 0 0)
(0 0 0 1)
> U!H * V!G;
Vector space of degree 4, dimension 3 over GF(2)
Generators:
(1 0 0 0)
(0 0 1 0)
(0 0 0 1)
(1 0 0 0)
(1 0 0 0)
Echelonized basis:
(1 0 0 0)
(0 0 1 0)
(0 0 0 1)
\end{code}
\end{example}

\subsection{Manipulating tensor data}
The data from a tensor is accessible in multiple ways.   For 
tensors given by structure constants this can be described as the 
multidimensional analog of choosing a row or column of a matrix.
Other operations are generalization of the transpose of a matrix.
We do these operations with some care towards efficiency,
e.g. it may not physically move the values in a structure constant
sequence but instead permute the lookup of the values.


\index{Slice}\index{InducedTensor}
\begin{intrinsics}
Slice(T, grid) : TenSpcElt, [SetEnum] -> SeqEnum
InducedTensor(T, grid) : TenSpcElt, [SetEnum] -> TenSpcElt
\end{intrinsics}

Returns the slice of the structure constants running through the given grid. 
For a tensor framed by free modules $[U_v,\dots,U_0]$ with $d_i=\dim U_i$, 
a grid is a sequence $[G_v,\dots,G_0]$ of subsets $G_i\subseteq \{1..d_i\}$.
The slice is the list of entries in the structure constants of the tensor
indexed by $G_v\times \cdots \times G_0$. {\tt Slice} returns the structure
constants whereas {\tt InducedTensor} produces a tensor with these
structure constants. 

\begin{example}[Ten\_Slice]
We demonstrate slicing. If every $G_i=\{1..d_i\}$, then the result is the same as {\tt Eltseq}.

\begin{code}
> U := VectorSpace(Rationals(),4);
> V := VectorSpace(Rationals(),3);
> W := VectorSpace(Rationals(),2);
> TS := TensorSpace([U,V,W]);
> T := TS![ i : i in [1..24] ];
> Slice(T,[{1..4},{1..3},{1..2}]);  // structure constants
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
18, 19, 20, 21, 22, 23, 24 ]
\end{code}

We obtain the slice data as structure constants of a tensor.

\begin{code}
> Slice(T,[{1..4},{2},{1}]); 
[ 3, 9, 15, 21 ]
> 
> W1 := VectorSpace(Rationals(),1);
> pi := hom< W -> W1 | <W.1,W1.1>, <W.2,W1!0> >; // project
> Eltseq( (T*V.2)*pi );
[ 3, 9, 15, 21 ]
\end{code}

However, in this example, the tensors are not the same. 
When we compress the induced tensor, then they become equal.

\begin{code}
> T_ind := InducedTensor(T,[{1..4},{2},{1}]);
> T_ind;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over Rational Field
U1 : Full Vector space of degree 1 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
> S := (T*V.2)*pi;
> S;
Tensor of valence 1, U1 >-> U0
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
> 
> Compress(T_ind) eq S;
true
\end{code}
\end{example}

\index{SliceAsMatrices}
\begin{intrinsics}
SliceAsMatrices(T, grid, i, j) : TenSpcElt, SeqEnum[SetEnum], RngIntElt, RngIntElt -> [Mtrx]
\end{intrinsics}

Returns a sequence of matrices equivalent to composing {\tt Slice} and {\tt AsMatrices}.

\index{Foliation}
\begin{intrinsics}
Foliation(T, i) : TenSpcElt, RngIntElt -> Mtrx
\end{intrinsics}

For a tensor $T$ contained in $\hom(U_v\otimes \cdots \otimes U_1,U_0)$,
return the matrix representing the linear map 
$U_i\rightarrow \hom(\bigotimes_{j\ne i}U_i,U_0)$ using the bases of each $U_j$.
If $i=0$, then the returned matrix is given by the represention 
$U_0^*\rightarrow \hom(\bigotimes U_i,K)$.

\index{AsTensorSpace}
\begin{intrinsics}
AsTensorSpace(T, i) : TenSpcElt, RngIntElt -> TenSpc, Mtrx
\end{intrinsics}

Returns the associated tensor space of $T$ at $i>0$ along with a matrix given by
the foliation of $T$ at $i$. 
The returned tensor space is framed by 
$U_v\times \cdots \times U_{i+1}\times U_{i-1}\times \cdots \times U_1\rightarrowtail U_0$
and is generated by the tensors $T_u$ for each $u$ in the basis of $U_i$.

\index{AsCotensorSpace}
\begin{intrinsics}
AsCotensorSpace(T) : TenSpcElt -> TenSpc, Mtrx
\end{intrinsics}

Returns the associated cotensor space of $T$ along with a matrix given by
the foliation of $T$ at $0$. 
The returned cotensor space is framed by 
$U_v\times \cdots \times U_1\rightarrowtail K$
and is generated by the tensors $Tf$ for each $f$ in the basis of $U_0^*$.

\index{AsTensor}
\begin{intrinsics}
AsTensor(T) : TenSpc -> TenSpcElt
\end{intrinsics}

Returns a tensor corresponding to the given tensor space. 
If the given tensor space is contravariant, then the returned tensor has the frame $U_v\times \cdots \times U_1\rightarrowtail T$.
If the given tensor space is covariant, then the returned tensor has the frame $T\times U_v\times \cdots \times U_1\rightarrowtail U_0$.
Note that {\tt AsTensor} is ``inverse'' to {\tt AsCotensorSpace} and {\tt AsTensorSpace} when $i=v$.

\begin{example}[Ten\_Foliation]
We demonstrate foliation.

\begin{code}
> T := RandomTensor( GF(7), [2,3,4] );
> Foliation(T,0);
[3 4 3 3 6 4]
[0 6 4 3 3 4]
[0 0 6 2 3 3]
[4 6 4 0 0 3]
> 
> Slice(T,[{1,2},{1..3},{3}]); // row 3
[ 0, 0, 6, 2, 3, 3 ]
> 
> Slice(T,[{2},{1},{1..4}]); // col 4
[ 3, 3, 2, 0 ]
\end{code}

The cotensor space associated to a tensor is the subcotensor space spanned by multilinear forms obtained from $T$.
For a fixed basis of $U_0$, we get a basis for the cotensor space by projecting onto various basis vectors of $U_0$.

\begin{code}
> CT := AsCotensorSpace(T);
> CT;
Cotensor space of dimension 4 over GF(7) with valence 1
U2 : Full Vector space of degree 2 over GF(7)
U1 : Full Vector space of degree 3 over GF(7)
> 
> S := Random(CT);
> MS := KMatrixSpace(GF(7),2,3);
> SystemOfForms(S) subset sub<MS|SystemOfForms(T)>;
true
\end{code}

The same applies for the associated tensor space to a tensor. 
We obtain a basis by projecting onto the basis vectors of $U_i$.

\begin{code}
> TS := AsTensorSpace(T,1);
> TS;
Tensor space of dimension 3 over GF(7) with valence 1
U1 : Full Vector space of degree 2 over GF(7)
U0 : Full Vector space of degree 4 over GF(7)
> 
> S := Random(TS);
> MS := KMatrixSpace(GF(7),2,4);
> AsMatrices(S,1,0) subset sub<MS|AsMatrices(T,2,0)>;
true
\end{code}
\end{example}

\section{Invariants of tensors}

To access the projections or the objects acting on a specific factor, the 
following should be used.

\index{Induce}
\begin{intrinsics}
Induce(X, i) : AlgMat, RngIntElt -> AlgMat, Map
Induce(X, i) : AlgMatLie, RngIntElt -> AlgMatLie, Map
Induce(X, i) : GrpMat, RngIntElt -> GrpMat, Map
\end{intrinsics}

Returns the induced sub-object associated to the $i$th factor of the 
associated 
tensor and a projection from the given object to the returned sub-object.

\subsection{Standard invariants}

We integrate the invariant theory associated to bilinear and multilinear maps
into the realm of tensors. 

\index{Radical}
\begin{intrinsics}
Radical(T, s) : TenSpcElt, RngIntElt -> ModTupRng, Map
\end{intrinsics}

Returns the $s$th (categorical) radical as a subspace of $U_s$ along with an isomorphism from $U_s$ to $K^{d_s}$.
If $U_s$ is already a vector space, then the returned map is the identity.

\index{Radical}
\begin{intrinsics}
Radical(T) : TenSpcElt -> Tup
\end{intrinsics}

Returns the tuple of all the $s$-radicals for each $s\in \{1,...,v\}$.

\index{Coradical}
\begin{intrinsics}
Coradical(T) : TenSpcElt -> ModTupRng, Map
\end{intrinsics}

Returns the (categorical) coradical of $T$ and a vector space surjection from 
the codomain to the coradical.

\subsection{Invariants for bilinear tensors}

The following are used only for tensors of valence 2.

\index{AdjointAlgebra}
\begin{intrinsics}
AdjointAlgebra(B) : TenSpcElt -> AlgMat
\end{intrinsics}

Returns the adjoint $*$-algebra of the given bilinear map. 

\begin{example}[Ten\_Adj\_Alg]
We get a pair of random cotensors from the exterior square of $V=\mathbb{F}_5^{10}$ and compute its adjoint $*$-algebra as a tensor.

\begin{code}
> V := VectorSpace(GF(5),10);
> E := ExteriorCotensorSpace(V,2);
> E;
Cotensor space of dimension 45 over GF(5) with valence 1
U2 : Full Vector space of degree 10 over GF(5)
U1 : Full Vector space of degree 10 over GF(5)
> 
> T := Random(E);
> S := Random(E);
> CT := SubTensorSpace(E,[T,S]);
> T2 := AsTensor(CT);
> T2;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 10 over GF(5)
U1 : Full Vector space of degree 10 over GF(5)
U0 : Full Vector space of degree 2 over GF(5)
> 
> A := AdjointAlgebra(T2);
> RecognizeStarAlgebra(A);
true
> Star(A);
Mapping from: AlgMat: A to AlgMat: A given by a rule [no 
inverse]
\end{code}
\end{example}

\index{LeftNucleus!bilinear} 
\begin{intrinsics}
LeftNucleus(B) : TenSpcElt -> AlgMat
\end{intrinsics}

Returns the left nucleus of the bilinear map $B$ as a subalgebra of $\text{End}_K(U_2)\times \text{End}_K(U_0)$.

\index{MidNucleus!bilinear} 
\begin{intrinsics}
MidNucleus(B) : TenSpcElt -> AlgMat
\end{intrinsics}

Returns the mid nucleus of the bilinear map $B$ as a subalgebra of $\text{End}_K(U_2)\times \text{End}_K(U_1)$.

\index{RightNucleus!bilinear}
\begin{intrinsics}
RightNucleus(B) : TenSpcElt -> AlgMat
\end{intrinsics}

Returns the right nucleus of the bilinear map $B$ as a subalgebra of $\text{End}_K(U_1)\times \text{End}_K(U_0)$.

\subsection{Invariants of general multilinear maps}

The following functions can be used for general multilinear maps.

\index{Centroid!tensor}
\begin{intrinsics}
Centroid(T) : TenSpcElt -> AlgMat
\end{intrinsics}

Returns the centroid of the tensor as a subalgebra of $\prod_{i=0}^v\text{End}_K(U_i)$.

\begin{example}[Ten\_Centroid]
We will compute the centroid of the tensor given by field multiplication in $\mathbb{F}_{3^{25}}$ as a subalgebra of $M_{25}(\mathbb{F}_3)$.

\begin{code}
> A := MatrixAlgebra(GF(3),25);
> f := RandomIrreduciblePolynomial(GF(3),25);
> S := sub< A | CompanionMatrix(f) >; // GF(3^25) inside A
> T := Tensor(S);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Matrix Algebra of degree 25 with 1 generator over GF(3)
U1 : Matrix Algebra of degree 25 with 1 generator over GF(3)
U0 : Matrix Algebra of degree 25 with 1 generator over GF(3)
> C := Centroid(T);
> Dimension(C);
25
> Ngens(C);
1
\end{code}
\end{example}

\index{DerivationAlgebra!tensor}
\begin{intrinsics}
DerivationAlgebra(T) : TenSpcElt -> AlgMatLie
\end{intrinsics}

Returns the derivation Lie algebra of the tensor as a Lie subalgebra of $\prod_{i=0}^v\text{End}_K(U_i)$.

\index{Nucleus}
\begin{intrinsics}
Nucleus(T, s, t) : TenSpcElt, RngIntElt, RngIntElt -> AlgMat
\end{intrinsics}

Returns the $st$-nucleus ($s\ne t$) of the tensor as a subalgebra of $\text{End}_K(U_i)\times \text{End}_K(U_j)$, 
where $i=\max(s,t)$ and $j=\min(s,t)$.

\begin{example}[Ten\_Der\_Nuc]
We first construct the derivation of the quaternion algebra over $\mathbb{Q}$ and verify that it is of type $A_1$.

\begin{code}
> H := QuaternionAlgebra(Rationals(),-1,-1);
> T := Tensor(H);                           
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Quaternion Algebra with base ring Rational Field, 
defined by i^2 = -1, j^2 = -1
U1 : Quaternion Algebra with base ring Rational Field, 
defined by i^2 = -1, j^2 = -1
U0 : Quaternion Algebra with base ring Rational Field, 
defined by i^2 = -1, j^2 = -1
> D := DerivationAlgebra(T);
> SemisimpleType(D);
A1
\end{code}

Now we verify that the mid nucleus of $T$ is the quaternion algebra.

\begin{code}
> ChangeTensorCategory(~T,HomotopismCategory(2));
> N := Nucleus(T,2,1);
> Dimension(N);
4
> N.1^2 eq N!-1;
true
> N.2^2 eq N!-1;
true
> N.1*N.2 eq -N.2*N.1;
true
\end{code}
\end{example}

If the centroid of a tensor is a commutative local ring, we can rewrite a tensor over its centroid.
We employ the algorithms developed by Brooksbank and Wilson \cite{BW:Module-iso} to efficiently determine if a matrix algebra is cyclic.

\index{TensorOverCentroid}
\begin{intrinsics}
TensorOverCentroid(T) : TenSpcElt -> TenSpcElt, Hmtp
\end{intrinsics}

If the given tensor $T$ is framed by $K$-vector spaces, then the returned tensor is framed by $E$-vector spaces where $E$ is the residue field of the centroid. 
The returned homotopism is an isotopism of the $K$-tensors.

\begin{example}[Ten\_Over\_Cen]
We construct a pc presentation of the upper unitriangular matrices over $\mathbb{F}_{1024}$. 
This will ``forget'' the field structure of our group, so that the tensor given by the commutator will be over $\mathbb{F}_2$.
We will use the centroid to rewrite our tensor as an alternating form over $\mathbb{F}_{1024}$.

\begin{code}
> G := ClassicalSylow( GL(3,1024), 2 );
> P := PCPresentation( UnipotentMatrixGroup(G) );
> T := pCentralTensor(P,1,1);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 20 over GF(2)
U1 : Full Vector space of degree 20 over GF(2)
U0 : Full Vector space of degree 10 over GF(2)
> TC := TensorOverCentroid(T);
> TC;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 2 over GF(2^10)
U1 : Full Vector space of degree 2 over GF(2^10)
U0 : Full Vector space of degree 1 over GF(2^10)
> IsAlternating(TC);
true
\end{code}
\end{example}

We include some well-known polynomial invariants for bilinear maps.
\index{Discriminant}
\begin{intrinsics}
Discriminant(B) : TenSpcElt -> RngMPolElt
\end{intrinsics}

Returns the discriminant of the bilinear map.

\index{Pfaffian}
\begin{intrinsics}
Pfaffian(B) : TenSpcElt -> RngMPolElt
\end{intrinsics}

Returns the Pfaffian of the antisymmetric bilinear map.

\begin{example}[Ten\_Disc\_Pfaff]
We construct the discriminant and the Pfaffian of an antisymmetric 2-tensor.

\begin{code}
> J := Matrix(GF(7),[[0,1],[-1,0]]);
> J;
[0 1]
[6 0]
> M := [ InsertBlock(ZeroMatrix(GF(7),4,4),J,i,i) 
      : i in [1..3] ]; 
> M;
[
    [0 1 0 0]
    [6 0 0 0]
    [0 0 0 0]
    [0 0 0 0],

    [0 0 0 0]
    [0 0 1 0]
    [0 6 0 0]
    [0 0 0 0],

    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 1]
    [0 0 6 0]
]
> T := Tensor(M,2,1);
> T;
Tensor of valence 2, U2 x U1 >-> U0
U2 : Full Vector space of degree 4 over GF(7)
U1 : Full Vector space of degree 4 over GF(7)
U0 : Full Vector space of degree 3 over GF(7)
> Discriminant(T);
$.1^2*$.3^2
> Pfaffian(T);
$.1*$.3
\end{code}
\end{example}

\section{Exporting tensors}
Tensors can be used define algebraic structures such as groups and algebras.

\index{HeisenbergAlgebra}
\begin{intrinsics}
HeisenbergAlgebra(B) : TenSpcElt -> AlgGen
\end{intrinsics}

Returns the Heisenberg algebra $A$ induced by the bilinear tesnor $B$. If $B=\circ : 
U\times V\rightarrowtail W$ is a bilinear map of $K$-vector spaces, and $U$, $V$, and 
$W$ are isomorphic, then $A$ is the algebra over $U$ with the given product. 
If 
$U$ and $V$ are isomorphic but not with $W$, then $A$ is the algebra over 
$U\oplus W$ with the given product. If $U$ is not isomorphic to $V$, then it 
creates a new bilinear map $\bullet:(U\oplus V) \times (U\oplus V)\rightarrowtail W$, 
where 
\[ (u,v)\bullet (u',v') = u\circ v'. \]

\index{HeisenbergLieAlgebra}
\begin{intrinsics}
HeisenbergLieAlgebra(B) : TenSpcElt -> AlgLie
\end{intrinsics}

Returns the Heisenberg Lie algebra with Lie bracket given by the alternating 
bilinear tensor induced by $B$.

\index{HeisenbergGroup}\index{HeisenbergGroupPC}
\begin{intrinsics}
HeisenbergGroup(B : parameters) : TenSpcElt -> GrpMat
    UseAlt : BoolElt : true
HeisenbergGroupPC(B : parameters) : TenSpcElt -> GrpPC
    UseAlt : BoolElt : true
\end{intrinsics}

Returns the class 2, exponent $p$, Heisenberg $p$-group with commutator given by the bilinear tensor $B: U \times V \rightarrowtail W$ over a finite field. 
If $B$ is alternating and {\tt UseAlt} is set to {\tt true}, then the group returned is an extension of $V$ by $W$, so $|G| = |V|\cdot |W|$. 
On the other hand, if either $B$ is not alternating or {\tt UseAlt} is set to {\tt false}, then the group returned is an extension of $U\oplus V$ by $W$, so $|G| = |U|\cdot |V| \cdot |W|$.  
The intrinsic {\tt HeisenbergGroupPC} uses the {\tt pQuotient} functions to convert a finitely presented group into a polycyclic group, so this can only return groups of order $\leq p^{256}$. 


\begin{example}[Ten\_Heisenberg]
From a single 2-tensor we construct an algebra, a Lie algebra, and a $p$-group.

\begin{code}
> T := RandomTensor(GF(3),[10,10,4]);
> V := Domain(T)[1];
> V.1*T*V.2;
(0 0 1 0)
> A := HeisenbergAlgebra(T);
> A;
Algebra of dimension 14 with base ring GF(3)
> A.1*A.2;
(0 0 0 0 0 0 0 0 0 0 0 0 1 0)
\end{code}

Now we create the Lie algebra. 
The tensor $T$ is not alternating, so it will induce an alternating tensor form which to create the Lie algebra.

\begin{code}
> L := HeisenbergLieAlgebra(T);
> L.1*L.2;
(0 0 0 0 0 0 0 0 0 0 2 0 1 0)
> T2 := AlternatingTensor(T);
> V.1*T2*V.2;
(2 0 1 0)
\end{code}

Now we create the Heisenberg $3$-group $G$ from $T$.
Because this algorithm uses the $p$-quotient algorithms, the commutator on $G$ will not be identical to the induced alternating tensor $T_2$. 
Instead, it will be pseudo-isometric to the $T_2$.

\begin{code}
> G := HeisenbergGroup(T);  
> (G.2,G.1);  // Defining word for 1st gen in Frattini
G.11
\end{code}
\end{example}

